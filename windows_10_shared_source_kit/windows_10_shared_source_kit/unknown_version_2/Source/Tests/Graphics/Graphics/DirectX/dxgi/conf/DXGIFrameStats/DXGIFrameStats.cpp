ÒÄÊ×«µÂ©²¾­³Â®´Á®³¿ª¯»¢©¸§¯¿®µÄ²·Å²µÂ°±¾­¯¼¬­ºª¨¶£¡¯¥¢±­§¸±«¹¯­¹±®¹³­»°­¼®©·©¢¯«¨²®¯¸¬¯¸±´¾º»Ç¬°¾ÊĞÚÌÏØ³±¹§¢§¤Ÿ ›•™œ—œ¢œ ¥› ¦š¡¥š£¦¦£¥¦©£œ¨¤›§¡š§š“¡›”¢‹‰•‚„Š™{Šrw}ƒZRX?>AVY[edj]UdG>J3/8($/)'l‚Œœ—Ÿ¥›®§ ³«´±ª©¯°ÆÊÀçÜÎÚÊ½ÒÂ´ÉÀ³Á½´¼¼³ÊËÃÜÚ××ÔÑÖÑÊ×ÉÁÉ»µ°¥¢ ™•›–’‘‰ œ©£¤§¡¥˜–¾ÇÍ¼¸½©£¦ª¢¦¸°±¹´³½¸µµ«¬§š¨‚|w~’€‹™¤£©–’‘••˜š“š˜¡“˜•¢£¦®š¨‰‘šˆ”€‚‡x{||€ƒƒ„Š…„‚ƒˆŠ’‡–is‚]bugdu„‚œ‹š††Šˆ’Š—mfpXUZTPUTV`VZmWZvSYoZbrfo|_fm\afX^f`etcizfm~bewTWbHMUT\dw€’’­±²ÉÇÇËÂÉÊÄÈ¿º½¹´¸½¹¾ÃÃËÀ¿Ë¹¸Ãº¸¿¿¼ÁÈÆÉÌËÎ¿¾Á»¶¼½¶¿»µ¿´²»µµ¾³®¸®ª³®­¶®­´¯¬³­ª³®¬²°­±µ°´»µº­©§¶ÄÊ¾ÈÎºÄË°ºÁ¼ÃÆÕÕ×ÑÒÒÇÉËØØÜØØÛİßáãèççççÇÄÄ\b_$+(087AIIJROV^[mvr~…‰Š…”–‰œœ‘—œ‘‹•‹qzpntlqwt„„ƒ†‰ƒƒ„xut~}x—”’‡ŠSNQ($,$!'')%$313<;;BBR`co‚‚q€€[beMVWHSS?EG%+*182`dhnyƒq~an‡q€—~œu‚’s’{Œ™xŠ––¢¬¹¿Ë­³¿§°¹¨±¹­³¾®²¿©­¸©­¸¡§³¢©¸«±¿±´Á°±¾®¯¼³²Àª¨¶¥¢°¤¡¯›«¤Ÿ°­¨µ¯¬¶°®·°®¹¹ºÆ²¯¼ª§³­°¹¶»Ä¯´½¹»ÆÇÈÔ½¼Í¼»Æª¥®‘‹’—“• Ÿ›Ÿ˜¡›£›§¥¬¢ª¥¦£›¢§œ¨¥š¨¥š¦ ™¥¢œª¢ªŒ‰”wzƒ‰“~€Œdbk?7?:28538,,3,,530:307,/2$&*"" ,(k}„”’›”¨­¢¸´¦´­£ŸŸœºº¯ØĞÃÒÊÀÏÈ¶ÓÌ¼ÛØÌÙÙÑÛÙÔß×ÓÔËÅâ×ÎÜÌÅÍ¼¸´§¥ª Ÿ«  š”’ª¦§¬¥©©¢¥›·¾Ä¾»Äª¦¨¨¥¤¾º·Ç¾»Ï¿Á½¦²’€–†…™—¥¬¯¹©£«’’˜”Ÿ¡—£¥“œˆ˜‰•¦ª¨¨±¥¢®ª˜˜£‰”†‹…Œˆ‹‘“‡”{€ƒw}w|…lkyYVdXWaSQ[QNWTR\a]kf^mXRZ`^b^[aXS\^]mclˆfp“bhˆfmƒuy…z‚f]eWQ[_`mlt‡z‰z›€Š–bkqxƒ~‘€„œ—š¬§­º·¾¾ºÁ½¸À¸µ¾´³¼·³½µ±º±±º¹¹ÁÀ¿ÆÅÂÇ¿¼Àº·»º´¼¾¸Âº·Á¶³½´¯¹³®¸²±»³³º°®¶¬¬´°¯¶²²µµ³¶·³·µ®«¾ÊÏºÄÌ²ºÄ®´¼¶·¾ÏÌĞİÛÜÕÖØËÊĞÒĞÔÛØÛêéëØÒÕ…‚?CC8A>DJHX^Zeoi{…}™–›™› ¢–¦©œ¢–š¡”–Ÿ’x€t—‹²¸«™š–spt^\`UUWIJF==:4574>A=GNKQWT[Yhws†—˜€’tƒ„‡“—–w|~PY]RZ\S[[UW[BAB01,Y\[}‡}‰™t™vƒ˜rt{‡–{‰•|—­´²¼Ä©°º¯´¼±¸½«³¼°¸Ã­´¿«°»¦«¶§ª·­°º®¯¹®¯¼«¬¹°®¼«¨¶£Ÿ¬¡ª¡Ÿ¬§¦²¨¥±««µ©ª´««³¿ÀÇ»¹Ãµ³À°³¾²¸Á²·À«®¹¤¥²œ¬š™£’Œ”š’˜ šœŸ™›Ÿ—š˜œ š›£›¥¡¦£¥£¢™Ÿ –¡¢™¥£š¦—£¤ª°¨¶—•u€…x†x‚‹agoDFK9:>7694263294182030..4/.026$(.$$Xme“‰™˜™§ ¯²©º·­­«¦¯¯£ÌÆºÌÆ½ÌÈ¸ÚÒÃáÚÌÜÕÌÓËÅÕÊÃÕÈ¾ÚÍÀØÎÃĞÄ½Â¶±¬¡§œ›‘‰‡’ŒŒ¦ª£Ÿ¦¡ ©«³·µÀ²±´À¾¾ÌÃÄÁ´¸±¢­…™ª¶³·Á½Á¥ ¨”•ŸŠ™‰–™¢§”š¤”œ£©´¼£¬·£°¦²Ÿ¥°›Ÿ¨’–Œ“™‘˜™–œ™¤¢¥ª¤¨¬’›rr‚adv^fv_hu^fp_ft\`tZ\nacpjnzps€}€Œ|‚’my–gp—ci[ddixts}qmsnjobbm]atks‰mv„z„“iow|ƒ—›–•“••†„‹¢£«±±»¹¸Ä´³¿¯­·³®·°©´¨©´ª¬¸«¬¸µ²¼º¹À±³¹©ª±´²¼¹¸Á¸·Á³´½³³¼¯±º²³º·¸À¹µÂ¸±½·³¹ÀººÀ¶´¯«¨¸ÅÇ¼ÅÈ½ÂÇ¹½ÄººÂÎÌÏéçäéçäÛÙÜÅÂÊ»¸½¨£©umrHFEDIHU_\hliszr{„zˆŒ…‘‘ˆ™—‰ ¡‘Ÿ“ ”’œ•œŠ“„¬²¦ÂÇ¹‡†B=@548HLL[b]_fcpuw‚‰—¦´´¡­ª£¬¬›¢¦t~ƒVah^eltwxuxzckn\ceV^ZU[XQSV121EGA‚•™›¦‹”Ÿ‡“˜“˜ƒ—{‡”˜¥®¹ÀÇ¹½Åµ»Å¶¼Ä´ºÂ¬±½«°¼¦®º«²¿¬°½¬®¹®±º­°º±³¿°°½¯¬º«¦µ§¤³¥¤²¤¥±«­¸µ²½µ²½µ²¾»¶ÁÂ¼Ç´¬¹®§¶«¨¹ªª¸¨ª´Ÿ©Ÿ™¨œš£˜Ÿ –œ¥™¥™¡—œ•›™Ÿ¡™Ÿ£™¡£›Ÿ¢œ¢˜ £– ¢—¢ ˜¢ š¤œ—¡£¨³¬¸œ¦wˆq~†s‰cp{TYe98?013,0/-./004.240/00--*+/!&*'&Ugb|Œš§¬¡¨§½Á·ÆÈ¿¸º³ÈÄ¹ÏÃ¸ÑÉ¼ŞĞÅâÒÅâÓÆİÑÅÔËÁÔÊ¿ÚÎÁßÓÈØÍÇĞÃ¿´©¨Ÿ›’’‡„„ œ™¯¬§³±²¬¦°¨¢«½»¾ÔÑÕ¿´¼»¬±ª¡ª©¢§¹°¸Å»¿º®¯²®¯»·¾´¬¶›˜¡‰”‘˜— —¡— §¨³º©³¾ ¨´£©°Ÿ¢®š §˜ £œ¤§ª¯´¯°¶»·¿­«·‹ puho‰cm„hvŒv‚–x•ltho‡inƒfk~ik{|€‘€ˆ™{‰o|•jtir†‰•”’–xrvvsyjluZ^k\dp\`kbiw]fp{„›œ«¢¨ŠKDJTUZmrx˜š¤­®¹­°»²²»¶²¼¶´¿²¯»±¯º³´¼³¸¾²¸¿³¶¾··À·¸Á¶¸Áµ·Áµ¶À´´¾±®¹Â¼Ç³¤µnz„‚„¥¥¡¸¬¨´¬¥ÀÉÍÉĞÓËÏÓ¿ÁÉº¼ÃÍÏĞïîéîéåĞËÌ œ£omrKJO?@BIRMYd`jtmvzr{x}‚zx‘ƒ­¨š¶±¡Ÿ“›‘˜š›š‚„‡|©¯¦­®¢rmh4/14<>y††’šš‡‘“™–‹”™£› ¤›Ÿ› £•¢¥‘qy‚u}‚ŠƒŒgopZb`[`_VW\/.0''$ECByv¢¨¦¤¬­¦¡¢”œŸ‹˜ ©´º½ÁÇ¿¿Èµ¸Ã±¶À®³¾§ª¸§«µª°ºª¯ºª­¹«°»¬´½¯¸Â¶¸Æ³³Á§£³²¬½¾¹É´°À©¤±¶°¹º³½²¨³­ ¯’¤”Œ –£œ”§¦­•¡™š˜˜¡– £›¤Ÿ•Ÿ“˜¥—œ¥—œ¡•š¢˜¢›¢¤›¢£—¡ –œŸ—š¡—¤—¨›¤¤š¢ ˜¡ š¤¤«ª£°™¥z}…q{ƒn|ƒfv€kq~GFQ+/2(11-23/57.67045/43212.12(40MaYsˆŸ™©³ˆ˜¤¥¯³ÃÆÉ½½ºÅÀ·ÍÁ¸ÔÆ¼×Ê¾ÜÎÀàÒÄŞÒÆÖËÂÒÇ¼ÕÉ¾ŞÓÉŞÓÍÙÍÉ¾´²›–—”’’Œ‰†š–”®ª­´±·§¢ªˆ’–“›µ±º°¨²³«­¸®­½¯¬¶¥ª¤“—Š„„•˜™²³·²¯´­«²®±·œ ¥‹“˜Š”™˜£§­¶»¬²»¥®œ¦«¤¬ ¥¬ ¥©§§«´³µ·»²®·‘”¡„‘¢ƒ¦}ƒ fsŒk}‘~¡}‹¢p~˜ktnr‰jm„eg}kp‚y‚ƒ’Ÿ‚“¥š«Œ“Ÿ¡©²©£°ŒŒwszty|hruiv{djtcfteow}„‰‘†j_h8365<<=CETW]jmu†‹” ¢«°¯¸¸·À½·Â®©³¦¨®¦¬±­±¸¶¶¾¸¸À³µ¾¸¹Ä¿½ÊÂºÉ¾°Áš‡™k{X@L0$$TSHƒx£¢š¾»¯¯µ¼¦­³›¢––š”–š§¦¨ÊÃÁÈ½¼’–qloBDD>GEQZVr|u‚…‚Œ‚~ˆ~y‚}z‚{‡œœª¥™¥œ‘’•Œ¥§¢§›™›•›—–›¥««¢ysn*))BPQ—¦©™¡¥‰“ŒŒ‘ƒ†Œ…Š’˜¢£¡¤¥¦ª¯·º°º½¦®±Š“•†‘•‹”mrv]cd_beWX^337*)),*+;46_UW‹}«Ÿ•© ™´°±ÀÅËÆÍÒ»¾Ä±²»¦«·¨²¼¬³¾­­»°±¹³´½­¬·¬ª¶¯®º¯±½¯²¾³²À¬¨¶›—¦‰—‰‰xmv{qw’Š‘•—‰€—‹›”‰ŠŠ ” ›• œ–•¡–¡•œ¢–¢•¢”š£•™£–›¡•š¢—¢™¤˜ ¡“Ÿ›œ’š¡”Ÿ¤– ¦š¢¢˜¡¡š£¤¦¥œ¨©¡­¤›§€}†ov}m}n€…}ƒŒ^[c0460777:<8<?6:=9=?>FFAC?<?<3<9@PKj€{’˜…™©–¨“¦²œ§¯²µ²Â¾µÆ¾´ÏÁ·ĞÆ¹ÕÊ½ÚÏÁÜÒÆÙÏÅÖÍÂÖÌÁİÑÈÚÎÇ×ËÆÊÀ¼¬¥¤™••’Œ‰•“¬¬³½º½®¦¬•“™š— ¥¥¨¸´±ÜËÊ´œbTXsrr~ƒs|™œ§«°§ª°¯±¹¸¸À¯¯³¢¦›¥¨¬µ¹«±¸£©±¡«°¤«®¥ª¯¢¦­¢§­§­³«¯¸—š¦|‡•z…–ª‹“­{‡Ÿ|Œ‚ z…ky“v™rwlrŠnvŒqzjr…biyfo}o|ˆŠ’™Ÿ§±—–§‘œ–””‹”“‹–›‡‘z‡’w€ˆusx~xvp{B;E+,,(00&,-%(+!&)*12FJJnmp…ƒŠ“Š’„y‚y€x~u}——¶±¹»¶À¶®¹—Š™ˆu…v]oM5G1!.&!#EHCgbXgaZ‹Š¯°¢¡¥¨£¤©Ÿ ¤‘—˜Š‘”’”š“‹ƒ]TZ86<-45?JI^fb’˜‘£œš –”–“œš“œ–¡©›¡¦˜›™‘•‰£š½¼³¶¶«¦¨Ÿ§¥«¥™˜¥¦£jif #"esrµ¿Á˜ ‹’“’”””˜Š‘–‘•¤¤¦¸·º¯¯µ©­²­°··¹¾…Œw€„†Šoqv`cf^_bXX^47;'**--/027)&,'! 1' D82VLJ†‚¿½Ã´®³¦œ¥°ª´¸¸ÀÀÀÇ·´»»º»º¹¼¶µ»Á¿Çº¹À®®²ª¨«˜–”Œ†ˆˆ‰NGQ0(,/++QKK„ˆˆ~v€œ• ˜¦™—£˜”¤š”¢ ›¢¤¢£œ¢¡™ –› ”›¡”š£–›¢—š¤™£™ Ÿ˜ŸŸ˜˜“— ’œ£— ¢˜ £–¡¢• £š¤¡›¥ œ¤¡š£¦œ¤¬¢ª±§°•˜lpvjzzm‚ƒŠgbg68:7;>EFIDFIDDGGHKBHJAFBACA;;?7CFh}€”}“¤—«¥³‹ §µ½ºÆÃ¾»¹³ÊÂ¸ÏÅ·ÓÈ»İÒÅäØÌŞÑÆİĞÆ×ÌÂÜÑÅßÓÊÛĞÉÒÈÄÆ½½ª£¦Ÿ›‘‰‹‹£¨¤º¸³¾·³¬©¨®«±Â¾ÀÖÆÊ³”K,31)(grp}…ˆs}u‚†¦±µŸ§¬—œ£ ¡©‘“¢|„’my†€™’¨™£¬¨°¹³º¿©¯¶Ÿ¥²‹‘£€ˆš…Ÿˆ“¢œ‡–¢‹š¦†•¥›«˜¦µŠ’¢‡›bnƒkuŠ‚Š ~ˆzˆšz†—q|“_h€]h{brƒlxˆx}…†›”¤§­¦­«ª®«™œ¡‚‰•xˆ‘‡‘™Š†•‰•\O^.'1&-,+01-351;<?LMDPPEJHCEF9<@:7<@;@JCJE=D2*27/7RIR_R\M>H7(25)44-722;69A7:;HMPd`_UMSaYX‘///
///
/// <copyright>
///  (C) Microsoft Corporation. All Rights Reserved.
/// </copyright>
///
///
/// <file>
///  $File$
/// </file>
///
/// <author>  $Author$ </author>
/// <date>    $Date$ </date>
/// <version> $Revision$ </version>
///
/// Information:
///
///
///
using WEX.TestExecution.Markup;

namespace Microsoft.Test.Networking.Wireless.Outerloop
{

    public partial class SystemTests
    {
        [TestProperty("Kits.TestId", "38099FC3-B893-4165-9727-5D4CE70D479E")]
        [TestProperty("Kits.TestId2", "365d7beb-e1c6-4477-ad91-f736cbabcb6d")]
        [TestProperty("Kits.TestName", "Wlan Test - Query Interface Properties")]
        [TestProperty("Kits.Description", "Query Interface Properties")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "7CA44864-F951-440C-A651-94CA797AF859")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        public void DeviceTest_QueryInterfaceProperties()
        {
            Test_02_QueryInterfaceProperties();
        }

        [TestProperty("Kits.TestId", "1559752D-39A8-4B28-A79F-13EFF48DC06D")]
        [TestProperty("Kits.TestId2", "5f5c9607-eb30-43aa-9eb4-c5e994e33f29")]
        [TestProperty("Kits.TestName", "Wlan Test - Toggle airplane mode")]
        [TestProperty("Kits.Description", "Toggle airplane mode")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.RunElevated", "True")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Scenario")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "EF206565-9163-438D-BB56-F7F9B4455882")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_ToggleAirplaneMode()
        {
            Test_06_ToggleAirplaneMode();
        }
        [TestProperty("Kits.TestId", "65EAC5B5-219F-459A-A8BE-B53B96D96A28")]
        [TestProperty("Kits.TestId2", "1205c9a8-ac68-4ac7-8656-64efe85a663e")]
        [TestProperty("Kits.TestName", "Wlan Test - Scan for Networks")]
        [TestProperty("Kits.Description", "Scan for networks using the Wlan device and expect results")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Scenario")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "5C671923-3FFF-4CA9-9A61-036EB3B3F375")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_ScanForNetworks()
        {
            Test_08_ScanForNetworks();
        }

        [TestProperty("Kits.TestId", "2C57AC94-F46E-4E40-9E23-AE6B0A397542")]
        [TestProperty("Kits.TestId2", "1bdd0f33-1d2c-437c-8161-e0d1dc75fafa")]
        [TestProperty("Kits.TestName", "Wlan Test - Attempt a connection to a non-existent network")]
        [TestProperty("Kits.Description", "Attempts a connection to a non-existent profile")]
        [TestProperty("Kits.ExpectedRuntime", "2")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Scenario")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "3664D3E6-751F-4B7C-B57A-02EBE628086E")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_NonExistentWlanProfileConnect()
        {
            Test_09_NonExistentWlanProfileConnect();
        }

        [TestProperty("Kits.TestId", "93197AC8-E6B8-4C2E-8252-B8AFEAD392A8")]
        [TestProperty("Kits.TestId2", "73436424-e997-46a8-9a9c-efb53a5c570e")]
        [TestProperty("Kits.TestName", "Wlan Test - Connect to a WPA2 PSK AES AP")]
        [TestProperty("Kits.Description", "Connect to a specified WPA2PSK AES network (Defaults: SSID=kitstestssid Passphrase=password)")]
        [TestProperty("Kits.ExpectedRuntime", "5")]
        [TestProperty("Kits.TimeoutInMinutes", "15")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.Parameter", "WPA2_PSK_AES_SSID")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.Description", "SSID of a WPA2_PSK_AES network to connect to (MUST be WPA2 PSK AES)")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.Default", "kitstestssid")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.IsRequired", "True")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.IsUserSettable", "True")]
        [TestProperty("Kits.Parameter", "WPA2_PSK_Password")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.Description", "Password for WPA2_PSK network")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.Default", "password")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.IsRequired", "True")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.IsUserSettable", "True")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Scenario")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "DC535BDE-D9D6-47E6-82BC-0F94272416D4")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_WlanConnectTest()
        {
            Test_10_WlanConnectTest();
        }

        [TestProperty("Kits.TestId", "2AE2CB26-EA04-4DEF-8E07-AE7B92E61E1B")]
        [TestProperty("Kits.TestId2", "0a737ffb-cbd2-41cd-a596-b939fbddc9ec")]
        [TestProperty("Kits.TestName", "Wlan Test - Connect to a WPA2 PSK AES AP with Sleep cycle")]
        [TestProperty("Kits.Description", "Connect to a specified WPA2PSK AES network with sleep resume (Defaults: SSID=kitstestssid Passphrase=password SleepDurationInSec=20, SleepCycleIterations=2)")]
        [TestProperty("Kits.ExpectedRuntime", "5")]
        [TestProperty("Kits.TimeoutInMinutes", "15")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.Parameter", "WPA2_PSK_AES_SSID")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.Description", "SSID of a WPA2_PSK_AES network to connect to (MUST be WPA2 PSK AES)")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.Default", "kitstestssid")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.IsRequired", "True")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.IsUserSettable", "True")]
        [TestProperty("Kits.Parameter", "WPA2_PSK_Password")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.Description", "Password for WPA2_PSK network")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.Default", "password")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.IsRequired", "True")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.IsUserSettable", "True")]
        [TestProperty("Kits.Parameter", "SleepDurationInSec")]
        [TestProperty("Kits.Parameter.SleepDurationInSec.Description", "The amount of time in seconds the device will asleep")]
        [TestProperty("Kits.Parameter.SleepDurationInSec.Default", "20")]
        [TestProperty("Kits.Parameter.SleepDurationInSec.IsRequired", "True")]
        [TestProperty("Kits.Parameter.SleepDurationInSec.IsUserSettable", "True")]
        [TestProperty("Kits.Parameter", "SleepCycleIterations")]
        [TestProperty("Kits.Parameter.SleepCycleIterations.Description", "The number of sleep/wake cycles to do")]
        [TestProperty("Kits.Parameter.SleepCycleIterations.Default", "2")]
        [TestProperty("Kits.Parameter.SleepCycleIterations.IsRequired", "True")]
        [TestProperty("Kits.Parameter.SleepCycleIterations.IsUserSettable", "True")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Scenario")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "DD82CA1B-FD19-4655-A1AE-1179B9E7D688")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_WlanConnectTestWithSleep()
        {
            Test_10_WlanConnectTest();
        }

        [TestProperty("Kits.TestId", "0DD672BA-55D9-4138-9B9A-129DB683506F")]
        [TestProperty("Kits.TestId2", "d24e1e1a-a659-4b60-8627-7ddbae382e3e")]
        [TestProperty("Kits.TestName", "Wlan Test - Check Hosted Network Capable")]
        [TestProperty("Kits.Description", "Checks that the device is capable of starting a hosted network (Soft AP)")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportHostedNetwork.HostedNetwork")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "E8A61651-2D52-474A-ACB5-290CCC959486")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        public void DeviceTest_CheckHostedNetwork()
        {
            Test_11_CheckHostedNetwork();
        }
        [TestProperty("Kits.TestId", "24f9bc8e-591d-4fa0-8dfd-735369428379")]
        [TestProperty("Kits.TestId2", "3d2f68b9-f4ce-43d1-87ec-898b008c4f12")]
        [TestProperty("Kits.TestName", "Wlan Test - Enable and Disable WFD Autonomous GO")]
        [TestProperty("Kits.Description", "Enables and disables Wifi-Direct Autonomous GO")]
        [TestProperty("Kits.ExpectedRuntime", "2")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportWiFiDirect.WiFiDirect")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "C4B0532B-314E-4DE8-9DBE-5BE1495684A9")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        public void DeviceTest_EnableDisableAutoGO()
        {
            Test_12_EnableDisableAutoGO();
        }

        [TestProperty("Kits.TestId", "1949BD77-A684-463F-9512-6812657B8706")]
        [TestProperty("Kits.TestId2", "efdacab3-52bc-42a0-81ae-0cad900db51f")]
        [TestProperty("Kits.TestName", "Wlan Test - Wlan Device Capabilities Check")]
        [TestProperty("Kits.Description", "Check the reported Wlan Device reported capabilities")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "14787C42-0CAD-49AC-9267-B05C8851C1AF")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_WlanCapabilitiesTest()
        {
            Test_13_WlanCapabilitiesTest();
        }
        [TestProperty("Kits.TestId", "ab3df3e5-1f37-46e4-9da9-a9663c803fb5")]
        [TestProperty("Kits.TestId2", "782846ed-7b82-4cd4-9bfb-4058ca4dc10f")]
        [TestProperty("Kits.TestName", "Wlan Test - Wlan Device Reset Check")]
        [TestProperty("Kits.Description", "Check the reported Wlan Device has properly implemented the reset functionality")]
        [TestProperty("Kits.ExpectedRuntime", "2")]
        [TestProperty("Kits.TimeoutInMinutes", "10")]
        [TestProperty("Kits.DisableDriverVerifier", "true")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "6CD757B9-CA2E-4488-8B50-A325B93924DA")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_WlanDeviceReset()
        {
            Test_14_WlanDeviceReset();
        }
        [TestProperty("Kits.TestId", "26568A8C-39CB-46EF-B8B8-E1BC835B05C1")]
        [TestProperty("Kits.TestId2", "f0a2e1d4-394d-4076-ac20-0a7d655f69b5")]
        [TestProperty("Kits.TestName", "Wlan Test - Query All Reported Oids")]
        [TestProperty("Kits.Description", "Check the reported Wlan Device does not bugcheck")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportConnectionToAP.ConnectionToAP")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "97678A51-82FF-4522-83F2-6B5A7652967B")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_QueryAllReportedOids()
        {
            Test_14_QueryAllReportedOids();
        }
        [TestProperty("Kits.TestId", "F27109B8-54CE-4279-8276-F5D2B8CB71F3")]
        [TestProperty("Kits.TestId2", "b08f847c-5bc1-45ea-b2da-3fa007429964")]
        [TestProperty("Kits.TestName", "Wlan Test - MAC Randomization test")]
        [TestProperty("Kits.Description", "Test MAC randomization against WPA2PSK AES network (Defaults: SSID=kitstestssid Passphrase=password)")]
        [TestProperty("Kits.ExpectedRuntime", "10")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportMACAddressRandomization.MACAddressRandomization")]
        [TestProperty("Kits.ExtendedDocumentation", "1C38D306-93A2-49D0-803B-9017CA6ED03A")]
        [TestProperty("Kits.Parameter", "WPA2_PSK_AES_SSID")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.Description", "SSID of a WPA2_PSK_AES network to connect to (MUST be WPA2 PSK AES)")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.Default", "kitstestssid")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.IsRequired", "True")]
        [TestProperty("Kits.Parameter.WPA2_PSK_AES_SSID.IsUserSettable", "True")]
        [TestProperty("Kits.Parameter", "WPA2_PSK_Password")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.Description", "Password for WPA2_PSK network")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.Default", "password")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.IsRequired", "True")]
        [TestProperty("Kits.Parameter.WPA2_PSK_Password.IsUserSettable", "True")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Scenario")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        [TestProperty("ThreadingModel", "MTA")]
        public void DeviceTest_MacRandomizationTest()
        {
            TestCase15_MacRandomizationTest();
        }

        [TestProperty("Kits.TestId", "B967267F-8E0A-43C1-9AB2-CC54D388E9C7")]
        [TestProperty("Kits.TestId2", "9a2117d6-c80b-40b7-9532-fc8e1e8cd8a1")]
        [TestProperty("Kits.TestName", "Wlan Test - Hotspot2 ANQP and GAS")]
        [TestProperty("Kits.Description", "Send and receive ANQP messages")]
        [TestProperty("Kits.ExpectedRuntime", "1")]
        [TestProperty("Kits.Specification", "Device.Network.WLAN.SupportHotspot2Dot0.Hotspot2Dot0")]
        [TestProperty("Kits.TimeoutInMinutes", "5")]
        [TestProperty("Kits.DevelopmentPhase", "Bring Up")]
        [TestProperty("Kits.TestType", "Development")]
        [TestProperty("Kits.Parameter", "queryTestDeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Description", "Device id of device under test")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.Default", "//Devnode/DeviceID")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsUserSettable", "False")]
        [TestProperty("Kits.Parameter.queryTestDeviceID.IsRequired", "False")]
        [TestProperty("Kits.ExtendedDocumentation", "BAED6237-8107-4F80-9A4E-EB504AEFEDFB")]
        [TestProperty("Kits.CorePackageComposition", "OneCoreUAP")]
        [TestProperty("Kits.CorePackageComposition", "Full")]
        [TestProperty("Kits.CorePackageComposition", "Mobile")]
        [TestMethod]
        public void DeviceTest_SendReceiveAnqpGasQuery()
        {
            Test_16_SendReceiveAnqpGasQuery();
        }
    }

}
ï»¿<?xml version='1.0' encoding='utf-8' standalone='yes'?>
<Content xmlns="http://microsoft.com/schemas/Windows/Kits/Manifest">
  <ContentGroup
      BuildArchitecture="each"
      Destination="$(_BuildArch)"
      >
    <FeatureReference Name="Device.Graphics"/>
    <BinaryFile
        Destination="nttest\windowstest\graphics\d3d\conf"
        Name="WGF11Interfaces.exe"
        Source="$(OBJ_PATH)\$(O)"
        />
  </ContentGroup>
</Content>
//-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
// File:	PackedRGB.fx
// Desc:	HLSL Shaders for PackedRGB texformats test group.
// Author:	Christopher Zamanillo
//-----------------------------------------------------------------------------

texture texPacked;
texture texEncoded;

sampler2D texPackedSampler =	
sampler_state 
{ 
	MagFilter	= Point;
	MinFilter	= Point;
	Texture		= <texPacked>;
};

sampler2D texEncodedSampler =	
sampler_state 
{ 
	MagFilter	= Point;
	MinFilter	= Point;
	AddressU	= Clamp;
	AddressV	= Clamp;
	Texture		= <texEncoded>;
};

float	g_fTolerance = 0.15f;		
float	g_fWidth = 64.f;			// texture width
float	g_fHeight = 64.f;			// texture height
float	g_fPairWidth = 0.03125f;	// width of two texels
float	g_fSingleWidth = 0.015625f; // width of one texel
bool	g_bGreenHiByte = true;		// whether the green component is in the high byte

/***************
 * Compares the color stored in the packed RGB texture with the color
 * we calculate in this shader.  Each 32-bit texel in the ARGB texture
 * contains a pair of 16-bit packed RGB texels.
 ***************/
float4 GetColorPS( float2 texCoords : TEXCOORD0 ) : COLOR
{
	// actual color
	float4 clrPacked = tex2D( texPackedSampler, texCoords );
	
	// encoded data
	float4 clrEnc;
	float2 texCoordEnc = texCoords;

	// are we on an even texel?
	bool bEven = fmod( texCoords.x, g_fPairWidth ) < g_fSingleWidth;
	float2 texelWidth = float2( g_fSingleWidth, 0 );
		
	float4 dataEnc = tex2D( texEncodedSampler, texCoordEnc );
	float4 dataEncRight = tex2D( texEncodedSampler, texCoordEnc + texelWidth );
	
	if( g_bGreenHiByte ) // FMT_G8R8_G8B8
	{
		if( bEven )
		{
			clrEnc.g = dataEnc.b;
			clrEnc.r = ( dataEnc.g + dataEncRight.g ) * 0.5f;
			clrEnc.b = ( dataEnc.a + dataEncRight.a ) * 0.5f;
		}
		else
		{
			clrEnc.g = dataEnc.r;
			clrEnc.r = dataEnc.g;
			clrEnc.b = dataEnc.a;
		}
	}
	else // FMT_R8G8_B8G8
	{
		if( bEven )
		{
			clrEnc.g = dataEnc.g;
			clrEnc.r = ( dataEnc.b + dataEncRight.b ) * 0.5f;
			clrEnc.b = ( dataEnc.r + dataEncRight.r ) * 0.5f;
		}
		else
		{
			clrEnc.g = dataEnc.a;
			clrEnc.r = dataEnc.b;
			clrEnc.b = dataEnc.r;
		}
	}
	
	clrEnc.a = 1.f;
	clrPacked.rgb /= 255.f;
	
	// if the actual and calculated colors are off by more 
	// than the tolerance then kill the pixel...
	if( distance( clrEnc.rgb, clrPacked.rgb ) > g_fTolerance )
		clip( -1 ); 
		
	return clrPacked;
}

technique GetColor
{
	pass p0
	{
		PixelShader = compile ps_2_0 GetColorPS( );
	}
}//-----------------------------------------------------------------------------
// File: DXGIFrameStats.cpp
//
// Desc: DXGI GetFrameStatistics tests.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
// Project headers
#include <initguid.h>
#include "DXGIFrameStats.h"

//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------
// Singleton application object need by test framework.
CMyTestApp g_Application;

//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Macro: HANDLE_HRESULT
// Desc: Expands to a block of code like the following:
//          case D3DERR_DEVICELOST:
//          {
//              return _T( "D3DERR_DEVICELOST" );
//          } break
//-----------------------------------------------------------------------------
#define HANDLE_HRESULT(x) case x:{ return _T(#x); } break

//-----------------------------------------------------------------------------
// Macro: LOG_RETURN_ON_NULL
// Desc: Helper to write to log and return on NULL
//-----------------------------------------------------------------------------
#define LOG_RETURN_ON_NULL( p, rt, msg) if(NULL == p){WriteToLog(msg); return rt;}

//-----------------------------------------------------------------------------
// Macro: LOG_RETURN_ON_NULL
// Desc: Helper to return on HRESULT FAILURE
//-----------------------------------------------------------------------------
#define RETURN_ON_HRESULT_FAILURE(hr, rt) {if(FAILED(hr)) {return rt;}}

//-----------------------------------------------------------------------------
// The window hellper class (CDXGISwapChainWindow)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Function: CreateTestWindow
// Desc: Create Test window
//-----------------------------------------------------------------------------
HRESULT CDXGISwapChainWindow::CreateTestWindow(RECT* pRect)
{
    RECT rect = { 0, 0, 640, 480 };
    if( NULL != pRect )
    {
        rect = *pRect;
    }

    if( NULL != m_hWnd )
        return E_FAIL;

    // Create/Register window class
    WNDCLASS WinCls = { 0, MsgProc, 0, sizeof(this),
        GetModuleHandle(0), NULL, NULL,
        (HBRUSH)(COLOR_WINDOW + 1),
        NULL, _T("DXGISwapChainWindowClass") };
    if( 0 == RegisterClass(&WinCls) )
    {
        DWORD RegisterClassError = GetLastError();
        if( ERROR_CLASS_ALREADY_EXISTS != RegisterClassError )
        {
            return E_FAIL;
        }
    }

    AdjustWindowRectEx( &rect, WS_OVERLAPPED, FALSE, 0);

    m_hWnd = CreateWindowEx( WS_EX_APPWINDOW,
        _T("DXGISwapChainWindowClass"),
        _T("DXGI Test Window"),
        WS_OVERLAPPED | WS_VISIBLE,
        0, 0,
        rect.right - rect.left,
        rect.bottom - rect.top,
        NULL, NULL,
        GetModuleHandle(0), (LPVOID)(this) );

    if( NULL != m_hWnd )
    {
        ShowWindow(m_hWnd, TRUE);
        SetWindowPos( m_hWnd, HWND_NOTOPMOST,
            0, 0, 
            rect.right - rect.left,
            rect.bottom - rect.top,
            0);
        SetWindowPos( m_hWnd, HWND_NOTOPMOST,
            0, 0, 
            rect.right - rect.left,
            rect.bottom - rect.top,
            0);

        return S_OK;
    }

    return E_FAIL;
}

//-----------------------------------------------------------------------------
// The Tests Baseclass (CDXGIFrameStatsTest)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Function: IncrementPresentCount
// Desc: Increments the present count for pDXGISwapChain
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::IncrementPresentCount(IDXGISwapChain* pDXGISwapChain)
{
    HRESULT hr = E_FAIL;

    // Verify input
    LOG_RETURN_ON_NULL(pDXGISwapChain, E_INVALIDARG, _T("IncrementPresentCount: Invalid input."));

    // Verify we have a render target view
    LOG_RETURN_ON_NULL(m_pRTView, E_FAIL, _T("IncrementPresentCount: No Render Target view."));

    // Verify we have access to a d3ddevice
    LOG_RETURN_ON_NULL(GetD3DDevice(), E_FAIL, _T("IncrementPresentCount: Unable to get D3DDevice from test framework."));  

    // Get a test resource
    LOG_RETURN_ON_NULL(m_pTestResource, E_FAIL, _T("IncrementPresentCount: No test resource to use."));  

    // Clear render target view
    FLOAT fRGBA[4] = { 0.0f, 0.0f, 0.5f, 1.0f };
    GetD3DDevice()->ClearRenderTargetView(m_pRTView, fRGBA);

    // Render test resource
    if( FALSE ==  m_pTestResource->UseResource(GetD3DDevice()) )
    {
        WriteToLog(_T("IncrementPresentCount: Use test resource failed."));
        return hr;
    }

    // Present.
    hr = pDXGISwapChain->Present(0,0);
    LogOnFailure(hr, _T("IncrementPresentCount: DXGISwapChain->Present() failed."));

    // Handle occlusion.
    if( DXGI_STATUS_OCCLUDED == hr )
    {
        WriteToLog(_T("IncrementPresentCount: Test is occluded."));
        return hr;
    }

    // Handle Present failure.
    if( FAILED( hr ) )
    {
        // Log more detail on device removal.
        if( hr == DXGI_ERROR_DEVICE_REMOVED )
        {
            WriteToLog(_T("IncrementPresentCount: GetDeviceRemovedReason reports %s."), D3DHResultToString(GetD3DDevice()->GetDeviceRemovedReason()).c_str());
        }

        return hr;
    }

    if( FALSE == GetOwnByFullScreen() ) // If windowed mode, FLIP_SQUENTIAL is used. Must re-bind render target after present
        GetD3DDevice()->OMSetRenderTargets(1, &m_pRTView, NULL);

    hr = S_OK;

    return hr;
}

//-----------------------------------------------------------------------------
// Function: CreateTestResource
// Desc:  Create the test resource
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::CreateTestResource()
{
    HRESULT hr = E_FAIL;

    ReleaseTestResource();

    switch( m_CurrentTestResource )
    {
    case D3D10VERTEXBUFFER:
        {
            m_pTestResource = new CDXGIResource_D3D10VB;
            break;
        }

    default:
        {
            WriteToLog(_T("CreateTestResource: Unknown resource type"));
            break;
        }
    }

    if( NULL == m_pTestResource )
    {
        WriteToLog(_T("CreateTestResource: Out of memory"));
        return E_FAIL;
    }

    // Create resource
    hr = m_pTestResource->CreateResource(GetD3DDevice(), GetFramework() );
    RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("CreateTestResource: Unable to create test resource")), RESULT_FAIL);

    return hr;
}

//-----------------------------------------------------------------------------
// Function: ReleaseTestResource
// Desc: ReleaseTestResource
//-----------------------------------------------------------------------------
void CDXGIFrameStatsTest::ReleaseTestResource()
{
    if( NULL != m_pTestResource )
    {
        delete m_pTestResource;
        m_pTestResource = NULL;
    }
}

//-----------------------------------------------------------------------------
// Function: SetupDWMStatus
// Desc: Setup DWM status flags 
//-----------------------------------------------------------------------------
BOOL CDXGIFrameStatsTest::SetupDWMStatus()
{
    BOOL rt = FALSE;
    HMODULE hdwm = NULL;
    PFDWMISCOMPOSITIONENABLED  pfnDwmIsCompositionEnabled = NULL;

    // Load DWMAPI
    hdwm = LoadLibraryExW(L"dwmapi.dll", NULL, 0);
    if( NULL == hdwm)
    {
        WriteToLog(_T("SetupDWMStatus: Failed to load dwmapi.dll."));
        goto cleanup;
    }

    // get funk pointer
    pfnDwmIsCompositionEnabled = (PFDWMISCOMPOSITIONENABLED)GetProcAddress(hdwm, "DwmIsCompositionEnabled");
    if( NULL == pfnDwmIsCompositionEnabled )
    {
        WriteToLog(_T("SetupDWMStatus: Failed to find DwmIsCompositionEnabled in dwmapi.dll."));
        goto cleanup;
    }

    if( FAILED(pfnDwmIsCompositionEnabled(&m_bDWMCompositionEnabled)) )
    {
        WriteToLog(_T("SetupDWMStatus: DwmIsCompositionEnabled Faild."));
        goto cleanup;
    }

    rt = TRUE;

cleanup:

    if( NULL != hdwm )
    {
        FreeLibrary(hdwm);
    }

    return rt;
}

//-----------------------------------------------------------------------------
// Function: TakeOwnership
// Desc:  Takes ownership over the output
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::TakeOwnership(IDXGISwapChain* pDXGISwapChain, IDXGIOutput* pDXGIOutput)
{
    HRESULT hr = E_FAIL;
    IDXGIOutput* pOutput = NULL;

    if( TRUE == GetOwnByFullScreen() )
    {
        // Verify input
        LOG_RETURN_ON_NULL(pDXGISwapChain, E_INVALIDARG, _T("TakeOwnership: Invalid input"));

        // Take ownership
        if( NULL == pDXGIOutput )
        {   
            // Get IDXGIOutput
            hr = GetSwapChainOutput(pDXGISwapChain, &pOutput);
            RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("TakeOwnership: GetSwapChainOutput failed")), RESULT_FAIL);

            // Set full screen
            hr = pDXGISwapChain->SetFullscreenState(TRUE, pOutput);
        }
        else
        {
            // Set full screen
            hr = pDXGISwapChain->SetFullscreenState(TRUE, pDXGIOutput);
        }

        LogOnFailure(hr, _T("TakeOwnership: DXGISwapChain->SetFullscreenState(TRUE) failed") );

        if( NULL != pOutput )
        {
            pOutput->Release();
            pOutput = NULL;
        }
    }
    // Don't need to take ownership for windowed mode.  Apps should never
    // call TakeOwnership directly.   TakeOwnership should have been an 
    // internal function, or at least have more limited exposure.
    //else
    //{
    //    // Verify input
    //    LOG_RETURN_ON_NULL(pDXGIOutput, E_INVALIDARG, _T("TakeOwnership: Invalid input"));
    //
    //    hr = pDXGIOutput->TakeOwnership(GetD3DDevice(), FALSE);
    //    LogOnFailure(hr, _T("TakeOwnership: DXGIOutput->TakeOwnership(FALSE) failed") );
    //}
    else
    {
        hr = S_OK;
    }

    if( SUCCEEDED(hr) )
        m_bOwnedResource = TRUE;

    return hr;
}

//-----------------------------------------------------------------------------
// Function: ReleaseOwnership
// Desc:  Release ownership over the output
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::ReleaseOwnership(IDXGISwapChain* pDXGISwapChain, IDXGIOutput* pDXGIOutput)
{
    HRESULT hr = E_FAIL;

    if( FALSE == m_bOwnedResource )
    {
        WriteToLog(_T("ReleaseOwnership: Don't have ownership"));
        return E_FAIL;
    }

    if( TRUE == GetOwnByFullScreen() )
    {
        // Verify input
        LOG_RETURN_ON_NULL(pDXGISwapChain, E_INVALIDARG, _T("ReleaseOwnership: Invalid input"));

        // Release ownership
        hr = pDXGISwapChain->SetFullscreenState(FALSE, NULL);

        LogOnFailure(hr, _T("ReleaseOwnership: DXGISwapChain->SetFullscreenState(FALSE) failed") );
    }
    else
    {
        // Verify input
        LOG_RETURN_ON_NULL(pDXGIOutput, E_INVALIDARG, _T("ReleaseOwnership: Invalid input"));

        // Release ownership
        pDXGIOutput->ReleaseOwnership();

        hr = S_OK;
    }

    if( SUCCEEDED(hr) )
        m_bOwnedResource = FALSE;

    return hr;
}

//-----------------------------------------------------------------------------
// Function: GetSwapChainOutput
// Desc: DXGISwapChain->GetContainingOutput()
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::GetSwapChainOutput(IDXGISwapChain* pDXGISwapChain, IDXGIOutput** ppDXGIOutput)
{
    HRESULT hr = E_FAIL;

    // Verify input
    LOG_RETURN_ON_NULL(pDXGISwapChain, E_INVALIDARG, _T("GetSwapChainOutput: Invalid input (pDXGISwapChain = NULL)"));
    LOG_RETURN_ON_NULL(ppDXGIOutput, E_INVALIDARG, _T("GetSwapChainOutput: Invalid input( ppDXGIOutput = NULL)"));
    if( NULL != *ppDXGIOutput )
    {
        WriteToLog(_T("GetSwapChainOutput: Invalid input(*ppDXGIOutput != NULL)"));
        return E_INVALIDARG;
    }

    // GetContainingOutput
    hr = pDXGISwapChain->GetContainingOutput(ppDXGIOutput);
    if( FAILED(hr) )
    {
        IDXGIOutput* pOutput = *ppDXGIOutput;
        if( NULL != *ppDXGIOutput )
        {
            pOutput->Release();
            pOutput = NULL;
        }
        WriteToLog(_T("GetSwapChainOutput: DXGISwapChain->GetContainingOutput() failed with %s"), 
            HResultToString(hr));

        return hr;
    }

    // Verify pOutput
    LOG_RETURN_ON_NULL(*ppDXGIOutput, hr, _T("GetSwapChainOutput: DXGISwapChain->GetContainingOutput succeeded but Output is NULL" ));

    return hr;
}

//-----------------------------------------------------------------------------
// Function: GetFrameStatistics
// Desc: GetFrameStatistics() for current resourec type being tested
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::GetFrameStatistics(IDXGISwapChain *pDXGISwapChain, IDXGIOutput *pDXGIOutput, DXGI_FRAME_STATISTICS* pFrameStats)
{
    HRESULT hr = E_FAIL;

    // Verify input
    LOG_RETURN_ON_NULL(pDXGISwapChain, E_INVALIDARG, _T("GetFrameStatistics: Invalid input (pDXGISwapChain = NULL)"));
    LOG_RETURN_ON_NULL(pDXGIOutput, E_INVALIDARG, _T("GetFrameStatistics: Invalid input (pDXGIOutput = NULL)"));

    switch( GetCurrentResourceType() )
    {
    case DXGIOUTPUT:
        hr = pDXGIOutput->GetFrameStatistics(pFrameStats);
        LogOnFailure(hr, _T("GetFrameStatistics: IDXGIOutput->GetFrameStatistics() failed") );
        break;

    case DXGISWAPCHAIN:
        hr = pDXGISwapChain->GetFrameStatistics(pFrameStats);
        LogOnFailure(hr, _T("GetFrameStatistics: IDXGISwapChain->GetFrameStatistics() failed") );
        break;

    default:
        hr = E_INVALIDARG;
        WriteToLog(_T("GetFrameStatistics: Unknown resource type"));
        break;
    }

    //    WriteToLog("   Frame Stats - PresentCount: %u, PresentRefreshCount: %u, SyncRefreshCount: %u, SyncQPCTime: %ld, SyncGPUTime: %ld", 
    //                pFrameStats->PresentCount, pFrameStats->PresentRefreshCount, pFrameStats->SyncRefreshCount, pFrameStats->SyncQPCTime, pFrameStats->SyncGPUTime);

    return hr;
}

//-----------------------------------------------------------------------------
// Function: GetFrameStatistics
// Desc: GetFrameStatistics() for current resourec type being tested
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::GetLastPresentCount(IDXGISwapChain *pDXGISwapChain, IDXGIOutput *pDXGIOutput, UINT* pLastPresentCount)
{
    HRESULT hr = E_FAIL;

    // Verify input
    LOG_RETURN_ON_NULL(pDXGISwapChain, E_INVALIDARG, _T("GetLastPresentCount: Invalid input (pDXGISwapChain = NULL)"));

    switch( GetCurrentResourceType() )
    {
    case DXGISWAPCHAIN:
        hr = pDXGISwapChain->GetLastPresentCount(pLastPresentCount);
        LogOnFailure(hr, _T("GetLastPresentCount: IDXGISwapChain->GetFrameStatistics() failed") );
        break;

    default:
        hr = E_INVALIDARG;
        WriteToLog(_T("GetLastPresentCount: Unknown resource type"));
        break;
    }

    return hr;
}

//-----------------------------------------------------------------------------
// Function: HResultToString
// Desc: Converts HRESULT to string
//-----------------------------------------------------------------------------
LPCTSTR CDXGIFrameStatsTest::HResultToString( IN HRESULT hResult ) const
{
    switch ( hResult )
    {
        HANDLE_HRESULT( S_OK );
        HANDLE_HRESULT( DXGI_STATUS_OCCLUDED );
        HANDLE_HRESULT( DXGI_STATUS_CLIPPED );
        HANDLE_HRESULT( DXGI_STATUS_NO_REDIRECTION );

        HANDLE_HRESULT( DXGI_ERROR_DEVICE_HUNG );
        HANDLE_HRESULT( DXGI_ERROR_DEVICE_RESET );
        HANDLE_HRESULT( DXGI_ERROR_DRIVER_INTERNAL_ERROR );
        HANDLE_HRESULT( DXGI_ERROR_DEVICE_REMOVED );
        HANDLE_HRESULT( DXGI_ERROR_INVALID_CALL );
        HANDLE_HRESULT( DXGI_ERROR_UNSUPPORTED );
        HANDLE_HRESULT( DXGI_ERROR_NOT_FOUND );
        HANDLE_HRESULT( DXGI_ERROR_MORE_DATA );
        HANDLE_HRESULT( DXGI_ERROR_WAS_STILL_DRAWING );
        HANDLE_HRESULT( DXGI_ERROR_NONEXCLUSIVE );
        HANDLE_HRESULT( DXGI_ERROR_FRAME_STATISTICS_DISJOINT );

        HANDLE_HRESULT( E_INVALIDARG );
        HANDLE_HRESULT( E_POINTER );
        HANDLE_HRESULT( E_FAIL );
        HANDLE_HRESULT( E_OUTOFMEMORY );

        HANDLE_HRESULT( E_NOTIMPL );
        HANDLE_HRESULT( E_NOINTERFACE );

        HANDLE_HRESULT( E_PENDING );

    default:
        return _T( "Unknown" );
        break;
    }
}

//-----------------------------------------------------------------------------
// Function: LogOnFailure
// Desc: Logs a message and HRESULT on failure
//-----------------------------------------------------------------------------
HRESULT CDXGIFrameStatsTest::LogOnFailure( IN HRESULT hResult, const TCHAR *szText  )
{   
    if( (FAILED(hResult) || DXGI_STATUS_OCCLUDED == hResult )&& NULL != szText)
    {
        WriteToLog(_T("%s HRESULT(%s),0x%x"), szText, HResultToString(hResult), hResult);
    }

    return hResult;
}

//-----------------------------------------------------------------------------
// Function: InitTestParameters
// Desc: Init the parameter for the test framework to iterate.
//-----------------------------------------------------------------------------
void CDXGIFrameStatsTest::InitTestParameters()
{

    // Fullscreen vs. Windowed mode factors
    //
    // Need to create seperate factors in order to apply different DCOMP factors.
    //
    CUserValueSet<BOOL> *pUseFullScreenValues = new CUserValueSet<BOOL>();
    pUseFullScreenValues->AddValue(TRUE);
    RFactor FullscreenFactor = AddParameter<BOOL>(_T("FullScreen"), &m_bOwnByFullScreen, pUseFullScreenValues);

    CUserValueSet<BOOL> *pUseWindowedValues = new CUserValueSet<BOOL>();
    pUseWindowedValues->AddValue(FALSE); // Window mode support added in Windows 8 (At least for Flip model swap effects).
    RFactor WindowedModeFactor = AddParameterValueSet<BOOL>(_T("FullScreen"), pUseWindowedValues);


    // Windowed vs. Windowless(DCOMP) SwapChain factors
    // Windowless(DCOMP) only supported in Windowed mode.  (Yeah... I know how funny that last sentence sounds)
    CUserValueSet<BOOL> *pDCOMPWindowed = new CUserValueSet<BOOL>();
    pDCOMPWindowed->AddValue(TRUE);
    pDCOMPWindowed->AddValue(FALSE);
    RFactor DCOMPWindowedFactor = AddParameter<BOOL>(_T("UseDCOMP"), &m_tp_bDCOMP, pDCOMPWindowed);

    CUserValueSet<BOOL> *pDCOMPFullscreen = new CUserValueSet<BOOL>();
    pDCOMPFullscreen->AddValue(FALSE);
    RFactor DCOMPFullscreenFactor = AddParameterValueSet<BOOL>(_T("UseDCOMP"), pDCOMPFullscreen);

    // The resource type
    CUserValueSet<TESTS_RESOURCETYPE> *pResourceTypeValues = new CUserValueSet<TESTS_RESOURCETYPE>();
    //pResourceTypeValues->AddValue(DXGIOUTPUT);
    pResourceTypeValues->AddValue(DXGISWAPCHAIN);
    RFactor ResourceFactors = AddParameter<TESTS_RESOURCETYPE>(_T("ResourceType"), &m_ResourceType, pResourceTypeValues);

    // Don't test DCOMP on Win7+8IP and below
    OSVERSIONINFO versionInfo;  
    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);  
    GetVersionEx(&versionInfo);  
    if(versionInfo.dwMajorVersion < 6 || (versionInfo.dwMajorVersion == 6 && versionInfo.dwMinorVersion < 2) )
    {
        SetRootTestFactor(ResourceFactors * ((FullscreenFactor * DCOMPFullscreenFactor) + (WindowedModeFactor * DCOMPFullscreenFactor)));
    }
    else
    {
        SetRootTestFactor(ResourceFactors * ((FullscreenFactor * DCOMPFullscreenFactor) + (WindowedModeFactor * DCOMPWindowedFactor)));
    }

}

//-----------------------------------------------------------------------------
// Function: InitNegativeTestParameters
// Desc: Init very limited parameters for negative tests.
//-----------------------------------------------------------------------------
void CDXGIFrameStatsTest::InitNegativeTestParameters()
{

    //
    // Run in fullscreen only
    //
    CUserValueSet<BOOL> *pUseFullScreenValues = new CUserValueSet<BOOL>();
    pUseFullScreenValues->AddValue(TRUE);
    RFactor FullscreenFactor = AddParameter<BOOL>(_T("FullScreen"), &m_bOwnByFullScreen, pUseFullScreenValues);

    //
    // Don't use DCOMP
    //
    CUserValueSet<BOOL> *pDCOMPWindowed = new CUserValueSet<BOOL>();
    pDCOMPWindowed->AddValue(FALSE);
    RFactor DCOMPWindowedFactor = AddParameter<BOOL>(_T("UseDCOMP"), &m_tp_bDCOMP, pDCOMPWindowed);

    //
    // The resource type
    //
    CUserValueSet<TESTS_RESOURCETYPE> *pResourceTypeValues = new CUserValueSet<TESTS_RESOURCETYPE>();
    //pResourceTypeValues->AddValue(DXGIOUTPUT);
    pResourceTypeValues->AddValue(DXGISWAPCHAIN);
    RFactor ResourceFactors = AddParameter<TESTS_RESOURCETYPE>(_T("ResourceType"), &m_ResourceType, pResourceTypeValues);


    SetRootTestFactor(ResourceFactors * FullscreenFactor * DCOMPWindowedFactor);
}


//-----------------------------------------------------------------------------
// Function: ExecuteTestCase
// Desc: Setups the test window, Swapchain, and calls RunCase() for each output
//-----------------------------------------------------------------------------
TEST_RESULT CDXGIFrameStatsTest::ExecuteTestCase()
{
    HRESULT hr = E_FAIL;
    TEST_RESULT tr = RESULT_FAIL;

    RECT winrect = { 0, 0, 640, 480 };

    CDXGISwapChainWindow myWindow;

    IDXGIFactory2* pDXGIFactory2 = NULL;

    IDXGISwapChain* pDXGISwapChain = NULL;

    IDXGIAdapter* pDXGIAdapter = NULL;

    IDXGIDevice* pDXGIDevice = NULL;


    // Verify test framework
    LOG_RETURN_ON_NULL(GetFramework(), RESULT_FAIL, _T("ExecuteTestCase: Unable to get test framework"));

    // Verify getting a DXGIFactory from the test framework
    LOG_RETURN_ON_NULL(GetDXGIFactory(), RESULT_FAIL, _T("ExecuteTestCase: Unable to get a DXGIFactory from test framework"));

    // Verify getting a D3D10Device from the test framework
    LOG_RETURN_ON_NULL(GetD3DDevice(), RESULT_FAIL, _T("ExecuteTestCase: Unable to get a D3D10Device from test framework"));

	// Need DWM
    if(FALSE == IsDWMCompositionEnabled() && GetOwnByFullScreen() == FALSE)
    {
        WriteToLog(_T("ExecuteTestCase: DWM composition is not enabled at start of test."));
        WriteToLog(_T("ExecuteTestCase: Frame statistics are not supported for windowed swap chains when DWM composition is disabled."));

        tr = RESULT_SKIP;
        goto cleanup;
    }

    // Get a window
    hr = myWindow.CreateTestWindow(&winrect);
    RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: CDXGISwapChainWindow->CreateTestWindow() failed")), RESULT_FAIL);
    LOG_RETURN_ON_NULL(myWindow.GetTestWindow(), RESULT_FAIL, _T("ExecuteTestCase: CDXGISwapChainWindow->CreateTestWindow() succeeded but can't get HWND"));
    SetTestWindow(myWindow.GetTestWindow());

    // Get DXGIDevice from framework
    hr = GetD3DDevice()->QueryInterface( IID_IDXGIDevice, (void**)&pDXGIDevice);
    RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: D3D10Device->QueryInterface(IID_IDXGIDevice) failed")), RESULT_FAIL);
    LOG_RETURN_ON_NULL(pDXGIDevice, RESULT_FAIL, _T("ExecuteTestCase: D3D10Device->QueryInterface(IID_IDXGIDevice) succeeded but pDXGIDevice = NULL."));

    // Get the DXGIAdapter
    hr = pDXGIDevice->GetAdapter(&pDXGIAdapter);
    RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: DXGIDevice->GetAdapter() failed")), RESULT_FAIL);
    LOG_RETURN_ON_NULL(pDXGIAdapter, RESULT_FAIL, _T("ExecuteTestCase: DXGIDevice->GetAdapter() succeeded but pDXGIAdapter = NULL."));

    // Get the DXGISwapChain
    DXGI_SWAP_CHAIN_DESC scd;
    ZeroMemory(&scd, sizeof(scd));
    scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    scd.SampleDesc.Count = 1;
    scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT|DXGI_USAGE_BACK_BUFFER;
    scd.Windowed = TRUE;
    scd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    if (m_tp_bDCOMP) // Should we use Windowless (DCOMP) presents?
    {
        // DCOMP Presentation
        scd.OutputWindow = NULL; 
        scd.BufferDesc.Width = 640; // We must specify buffer width and height with Windowless swapchains.
        scd.BufferDesc.Height = 480;
    }
    else // Regular windowed presentation
    {        
        scd.OutputWindow = myWindow.GetTestWindow();
        // No need to specify buffer dimensions.   DXGI will use the window client area for default dimensions.
    }

    scd.BufferCount = 2;

    if(FALSE == GetOwnByFullScreen() ) // If windowed mode, use FLIP_SEQUENTIAL (defaults to DISCARD for fullscreen).
        scd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;

    if( m_tp_bDCOMP )
    {
        DXGI_SWAP_CHAIN_DESC1 scd1;
        ZeroMemory(&scd1,sizeof(scd1));
        scd1.Width = scd.BufferDesc.Width;
        scd1.Height = scd.BufferDesc.Height;
        scd1.Format = scd.BufferDesc.Format;
        scd1.Stereo = FALSE;
        scd1.BufferCount = scd.BufferCount;
        scd1.BufferUsage = scd.BufferUsage;    
        scd1.SampleDesc.Count = scd.SampleDesc.Count;
        scd1.SampleDesc.Quality = scd.SampleDesc.Quality;
        scd1.Scaling = DXGI_SCALING_STRETCH;
        scd1.SwapEffect = scd.SwapEffect;
        scd1.Flags = 0;

        hr = GetDXGIFactory()->QueryInterface(__uuidof(IDXGIFactory2),(void**)&pDXGIFactory2);
        RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: DXGIFactory->QueryInterface() for IDXGIFactory2 failed")), RESULT_FAIL);
        IDXGISwapChain1* pSC1 = NULL;
        hr = pDXGIFactory2->CreateSwapChainForComposition(GetD3DDevice(),&scd1,NULL,&pSC1);
        RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: pDXGIFactory2->CreateSwapChainForComposition() failed")), RESULT_FAIL);
        pDXGISwapChain = pSC1;
        LOG_RETURN_ON_NULL(pDXGISwapChain, RESULT_FAIL, _T("ExecuteTestCase: pDXGIFactory2->CreateSwapChainForComposition() succeeded but pDXGISwapChain = NULL."));
    }
    else
    {
        hr = GetDXGIFactory()->CreateSwapChain(GetD3DDevice(), &scd, &pDXGISwapChain);
        RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: DXGIFactory->CreateSwapChain() failed")), RESULT_FAIL);
        LOG_RETURN_ON_NULL(pDXGISwapChain, RESULT_FAIL, _T("ExecuteTestCase: DXGIFactory->CreateSwapChain() succeeded but pDXGISwapChain = NULL."));
    }

    // Instantiate DCOMP if necessary
    if (m_tp_bDCOMP)
    {
        hr = m_DCOMPIsolation.CreateAndAssociateDCOMPVisual(pDXGISwapChain, myWindow.GetTestWindow());
        RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: CreateAndAssociateDCOMPVisual() failed")), RESULT_FAIL);
    }

    // Get backbuffer
    ID3D10Texture2D* pDXGIBackBuffer = NULL;
    hr = pDXGISwapChain->GetBuffer(0, __uuidof( ID3D10Texture2D ), (void**)&pDXGIBackBuffer);
    RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("DXGISwapChainrrentDevice->GetBuffer(IID_ID3D10Texture2D) failed")), RESULT_FAIL);
    LOG_RETURN_ON_NULL(pDXGIBackBuffer, RESULT_FAIL, _T("DXGISwapChainrrentDevice->GetBuffer(IID_ID3D10Texture2D) succeeded but pDXGIBackBuffer = NULL."));

    // Create render target view of backbuffer
    D3D10_RENDER_TARGET_VIEW_DESC rtvd;
    ZeroMemory( &rtvd, sizeof( rtvd ) );
    rtvd.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    rtvd.ViewDimension = D3D10_RTV_DIMENSION_TEXTURE2D;
    rtvd.Texture2D.MipSlice = 0;

    SAFE_RELEASE(m_pRTView);
    hr = GetD3DDevice()->CreateRenderTargetView(pDXGIBackBuffer, NULL, &m_pRTView);
    SAFE_RELEASE(pDXGIBackBuffer); // Done with backbuffer
    RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("D3D10Device->CreateRenderTargetView() failed")), RESULT_FAIL);
    LOG_RETURN_ON_NULL(m_pRTView, RESULT_FAIL, _T("D3D10Device->CreateRenderTargetView() succeeded but pView = NULL."));

    // Set render target view
    GetD3DDevice()->OMSetRenderTargets(1, &m_pRTView, NULL);

    // Setup the viewport
    D3D10_VIEWPORT vp;
    ZeroMemory(&vp, sizeof(vp));
    vp.Width = winrect.right - winrect.left;
    vp.Height = winrect.bottom - winrect.top;
    vp.MaxDepth = 1.0f;
    GetD3DDevice()->RSSetViewports( 1, &vp );

    // Get a test resource
    if( NULL == m_pTestResource )
    {
        hr = CreateTestResource();
        RETURN_ON_HRESULT_FAILURE(LogOnFailure(hr, _T("ExecuteTestCase: CreateTestResource failed")), RESULT_FAIL);
    }

    // Delay for a second to give DWM time to recover from fullscreen mode.
    Sleep(1000);

    // Test all outputs
    IDXGIOutput* pDXGIOutput = NULL;
    for(UINT iOutput = 0; SUCCEEDED(pDXGIAdapter->EnumOutputs(iOutput, &pDXGIOutput)); ++iOutput)
    {
        WriteToLog(_T("-------------------"), iOutput);
        WriteToLog(_T("Testing output: %u"), iOutput);
        WriteToLog(_T("-------------------"), iOutput);

        // Run the test case
        tr = RunCase(pDXGISwapChain, pDXGIOutput);

        // Cleanup the output
        if( NULL != pDXGIOutput )
        {
            pDXGIOutput->Release();
            pDXGIOutput = NULL;
        }

        // If we did not pass the test case on this output be done.
        if( RESULT_PASS != tr )
        {
            goto cleanup;
        }
    }

cleanup:

    // Release Factory2
    SAFE_RELEASE(pDXGIFactory2);

    // Release RenderTargetView
    SAFE_RELEASE(m_pRTView);

    // Release DXGISwapChain
    SAFE_RELEASE(pDXGISwapChain);

    // Relase DXGI Adapter
    SAFE_RELEASE(pDXGIAdapter);

    // Release DXGI Device
    SAFE_RELEASE(pDXGIDevice);

    // Release the TestResource
    ReleaseTestResource();

    // Clean up DirectComposition if necessary
    m_DCOMPIsolation.DestroyDCompDeviceAndVisual();

    return tr;
}

//-----------------------------------------------------------------------------
// The CDXGIIncrementPresentCountTest Test
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// Function: RunCase
// Desc: Verify that present will up the DXGI_FRAME_STATISTICS
//-----------------------------------------------------------------------------
TEST_RESULT CDXGIIncrementPresentCountTest::RunCase(IDXGISwapChain *pDXGISwapChain, IDXGIOutput *pDXGIOutput)
{
    // Verify input
    LOG_RETURN_ON_NULL(pDXGISwapChain, RESULT_FAIL, _T("RunCase: Bad input (DXGISwapChain = NULL)"));
    LOG_RETURN_ON_NULL(pDXGIOutput, RESULT_FAIL, _T("RunCase: Bad input (DXGIOutput = NULL)"));


    TEST_RESULT tr = RESULT_PASS;
    HRESULT hr = E_FAIL;
    UINT nTimeout;

    // Frame statistices before and after present
    DXGI_FRAME_STATISTICS fs1,fs2;
    ZeroMemory( &fs1, sizeof(fs1) ); // Before
    ZeroMemory( &fs2, sizeof(fs2) ); // After

    // Take ownership
    if( DXGISWAPCHAIN == GetCurrentResourceType() && FALSE == GetOwnByFullScreen() )
    {
        // We want the swapchain to GetFrameStats without having ownership
        WriteToLog(_T("Not taking ownership for this case."));
    }
    else
    {
        hr = TakeOwnership(pDXGISwapChain, pDXGIOutput);
        if( FAILED(hr) )
        {
            WriteToLog(_T("Unable to take ownership"));
            return RESULT_SKIP;
        }
    }

    // Present something to get everything started
    WriteToLog("Presenting an initial frame...");
    hr = IncrementPresentCount(pDXGISwapChain);
    if( DXGI_STATUS_OCCLUDED == hr )
    {
        WriteToLog(_T("Test is occluded - Unable to increment the present count"));
        ReleaseOwnership(pDXGISwapChain, pDXGIOutput);
        return RESULT_SKIP;
    }
    else if( FAILED(hr) )
    {
        WriteToLog(_T("Unable to increment the present count"));
        ReleaseOwnership(pDXGISwapChain, pDXGIOutput);
        return RESULT_FAIL;
    }

    // Pause for frame to be output and get baseline present stats
    WriteToLog("Pausing for a moment to give Present a chance to complete...");
    Sleep(1000);

    //
    // Clear out any initial DISJOINT error.  We always get 
    // DXGI_ERROR_FRAME_STATISTICS_DISJOINT on the first call to 
    // GetFrameStatistics, but we will also get the error after the first 
    // Present call when DWM is off.
    //
    WriteToLog("Calling GetFrameStatistics() to clear out any initial DISJOINT errors...");
    Get