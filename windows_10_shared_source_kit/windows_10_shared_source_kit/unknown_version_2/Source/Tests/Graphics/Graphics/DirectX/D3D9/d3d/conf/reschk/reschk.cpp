幠帝䶞幣䷢䷡庤度䷠丠澧滥潥庥廧交漥庤漥漡辥꾦迨澫濬澯ķŷŶĸļǾȿǽ˽˺ʺ̾ȺƹƷǸİĲǳƵȹŸɽƹȹƷǳɵƱǳǹȺ˼ŴƷǶŵȾȼʿȾޱ߯ౡޮ߬ଖᬔީઑએ੎ݪ૓૒૒ᬓᬕޭޮಟᱠⳠ߯ఝⴡⲟ㴣㵤൨ߵݵᵩ享䷧㷦䴜ᯗⰗᰗ㲘ⱘ䴙ᰘ䴚Ⱇ㲗䳘㳚㲛䶜䴙䵟䶞䴚䶟嶝帠両渠巟幡丠幢滤帠帟幢庠滣滨䷡潦庣弪乤潥羥滣廦羨濯µøĵ³ķĹƻƺǿǾǾǼȽƺǼǾɿʿʻʿȹʷöĲŶĶĲųűűǶųǹķƶǹȹƹȶîóƴɹ˾˾ʿžÿĿĿʻƶȴɹɺǻɾʾᰥܮ۫ޫޫݩݨݨި઒ݧଓީߩ᫒ઑઐ⭕⭘߯ଘ߰߮߮Ⳝ㲚䷠㵢ⷧᴦ⶧߲㷩㷤㵞Ⱉ䱕㲗Ⱈ㲘⯔ⲗ䴙䳘ᯗ䳘䴙䴙㲘䴘䵛䴚䴞帞嶜䴙帛帞䶜䶜帞䵝巟庥帢溤幣䷣幠庠帡廤溣廥廤漤罤幣澪羫辪澩²öᾰöõĸĶĺƺȿǽǼǾŹƹŹĴĶƷŷŶǺǺɽɾǿƽǼɽŸȼɻƺȼȹɼȻƸŵƴ°ı®îİðï¯ŵĳòŸƸƹŸĴıƲðƳȹǸǻʿɿĽͼɻŵîŶȺǻǹȿȿȿ஠ܪݩީީߩߪ૒ߪߪݨએܧߩߩީߩᬖ߫ଖ᭔ުᬒ⯖㯖ᰗ᳞᳚ⴝ䶢㴢᳢㶣ᵠⱘⰘ⯔ⱗ㰗㰖㱗ᯔ㳘ᯗ䴛䴙䴙㲘㲘䳚䵜䵚䵜嶛嶙䵙溛川嵚䵙滞帝䷢滥巡丣两廦帡帟庤乤滤廦严庤湡庣滧漩潪翫°´⿳³°Ĳķ¶ĸ÷ƹŸŶŷŸŸƸƶññıĳĴĴŵƹƹŸŸĴŸŶŷŷŸƹǹȺǸǻƺŴòĲõıïİ®ðĳŸŷĳĸŷŸŶðűıųŷųóŶƹŸȼǺǽľĿýľȺȺɺŴ«òƶȹǾީ۩٥ߪީܥݥ᪍਑਌᪏ߨަ᪐ߨ૔ᬕ૓߬⭓૒⮔߬⯖Ⱅୖᰘ䳘⯔㰖ⲛⱛᰘ⯔⯗䱖⮔Ⱆ䱖㱖㰗ᰖ䴙Ⱇ㰖䲘䳙䲘䲘㳜䵛䴙嶙䴙巚巚嶙䵛䵛両䶞䶜䶠州䷣䷠丣丣巟绥䷡溦庤庤庢庤䷢龧弨澪羪辫°潩澬õô÷ĸĹǺźǽŵŰ®Ĳĳŷ³òïðòĴĹŷŸƹŸŵĴĲŶŸŸŶƷɼǹƷƶƶĳĳòĵðñĲ濬îĲĵĶĸŷĶŴųŵůįĲðıŵƴŶŴŵŸŸǽÿȾǺ̿ƵǷƳ¯ŲŰŵɼߪݦ٣ݧਊަᨌੋަާ᫐ߨިާᩍ᫒᪏ݩ૒ᬑ᫑ᬑ⯖ᬔ᫑ଔଔ୓⮐᭒Ⱈ᭓୕ߪᯗ⭑㮕⮒ᮓᯓ⮒ⰗᯗⰗ㱘䲘ᯖ㳙䴙䴚䵜䴙䵙䴙䴙嶙巚嶛溛巜䵝䵚湠纡䶠䷡丣䷢㵝溤帣帤严幡溡绣庥潩仨潩廨徫®羫濪佫翬羪¬澨徫侭濬°¸õ±«­±ñ濪­Ĵıķö±²ó²ĸĵĵŶǹŶŶĲŰòĲŴñòõôűĲõ·ĶķĶŵĴĴı®­Ĳðķñŵð²ĲŷŸǻŽ¿žǾǾƽ˼ǸųŴŴ®ð«¯Ŷ˿ިޣݥܤ৊ަईݥڣܥਉݥߧݦݦ઎ੌઐߪ୕᫒ᬓ⫎૔ᬕߪ᭒᭓ᬐ᭒⬐᫒ᮔ୑㯑߫⮕㭑㳖⬏⭑ⲕ㰓㯔⮓㰕㱗䳙㱗䴘䲖䴙䴙䲖䳖䳕䴖䴘嵚嶚䶝川䶝州䵞䶞䶡乥丣䷠䷡乧䷣䷡廣缤廦䷣座庨缩翫羪庨弩澩濫伧濩澫徭澩俭´濪弥羥潨義翪澪¯濭徭濯濭濬佲㾳俲óĴ³ƴıñ±°ð³²Ĳĵ³ĵµõõ徭ð­®­¯¯ıĳîĲĵŷŹƼÿĿýſƽȿǾƹŸƷų¯¯翩¬îƶɼǼɼĶƼŸǻȽƼǿƼƼǿߧڣݥݤަۣޥݥݥާߧڣާݥި਋ި⩊ߩ᫐૔⫐᪎᫏⭔⬔⭐㱓⯏᭒᫏᭑୒ޫ㮓୔ᮒ⮓㯓⯐㲓ᰒⱒ㱔㯑㲕䴘䳘㰗䴙䳗㰕䴚㲖䲕䴘䳖䴗䴙䴘嶙䳘䶝䵝䷡㶡䶣㵡䶡䶡䵝严两乧䷠幥乨庥潦仩弬羪羫辩罧彩濬濬濩濬澩義弩¬濰濪澩羧潧翪羧澪濬澫濬澫微彭澭忲侯´µ±Ĵ±ðó¯±Ĵ³¶·ô·俲ĶöƸðİððïñ±°³ĳĲĴĴĴŷĻýǿǾǽǼķȿǽǽǽƺŹŷŸƸĳ¯«¬迧óǺ˾ȻǸȼŸŶĴĲŷķĵĶƻǿƹĴĴŴŷܢݥݢݣޤަݥঈߦߦߧۤᧈޥ੊ߨާߨީ᪎੎ߪ᪏ઑ⬓୔ު⮓⬐⮒ߩ᫐᭐઎଑୓୓୐⬎⭑⯑㮑ᬐ᭐䱐䲖⯖㲘㱖䳙䲗䲗䴙䳗䳖䳙䴘䳘䳗䳖䴙䵙䵜䴜㵞㵟䵢䷥䷠䷢䵞两严乥幣幥度漪罩廧翫廨庥潩潨弩翫漩潩澪濫佨潧彪佫⽮潩翮翫濪漤翨翪羫潬澬徬彭澫彬侯徯彭濰徳ö濴濰ĸ±忲ó··⿵¸ĵô³ôĲïò³ò³ôŶôóŶĶöŸĹĿļÿƿȿǾǾƽƻǿĻǽǾǼĹƶŶĴ°¬ª¬¥翤®ððĳŵǷɻ˿ǼƷǻǸŸŷŵò±®ñ­ŶźźĳĮ翩ĳô³ܡᤆܣݤߢݣܣࣅेߥॅߤޥڡݤަݥਉߧ੎᪎ᬓᨍ૓⬓ީઑߩૐ߫⬎᫐ߪ㭎ᬓ᫑᫑⮒଎⬍⮏㮏ᬐ⮑㭑㱔ᮔⰖ㲗䲖㲗䴗䳖㱖䳗䲖䳗䴗䴙䳚䳘䴙䳗䵚䵞㴡㴟䶢㴡䶟䷢䶟䷢丣严乧严乨产溣轨罦产辪漩廨潪濬潨澪潪廦廦潪弨廨弩彪翩漦廧潧濩翪彪澬伫京澭弫濰忰㽬徭澭彰濰忰侲㼯澰伭µ忯ó³㾴ø·㿶忷忳¸ôĴĴ¯´²ĳĶĴĶƸ÷·ŸûƿļýüĿÿĿƿǿȿǾǾƾŽƾǽƹĻķĶðð®翨羢罡羧ª«¨®íîį¬®®翪¬¬ïí¬羧迦義֟᥂ۡߥޤ١ޥޤܤޤޣޥݥ৉ߦݤޥ᪌਌᪍੏ݨઑާީ⫏᫏߫ީᫍީᬌު૏⫐⬑⮓⭐⮏⭐᫐⮏㯐⬐㭑ⱗ଎᭓⭑㯓⮑⮓㱗ⱖ㲖䲖䳕䳘䳘㯓㳘㲖䵛䴚䶝䵡㴡䴟㴝䶟䷢丣䷢严两乨严並严幦滧滥滥羨亨廨弨亨潬漩廨潩潩澪彪庩亨潨漦澫弨漥弩彪弩伮伮澭徯侳ᾲ⺫佭佰彲忴俵໲侲佰㿴⼯ó濲侶㽵¸⽷⾶·´²¶徰ó´侯²ô´´ķŸŸƸŹƻýſ¾ƿżĸƿĿǿǽƼøŸµôò澦侨罠潞羢潠罟羢翤迠羟潥濩濧羪翫翪羧弥彩彦ݡן؟ޣݣܣܤݦߥܡޤߣᤅݣަܤަݦᨊ᪎ݦܥᨎ᧌ݨ᪏૔ߩߨੌ੎ݩ߬᪏᪏߫߫૎૏㯓᭏ઍఒᬐ૒⬓᫐ᮔ⯒㯐㰕㰏䱕ⱖஔ䲕㱕ⱕ䲕㲖䴘㳘㴚ᰛᲜⴠⱞ㵣㴡䷡ⶠⶢ两䶡书乧严乥ⶥ乧幥书廦潩乧廨享亨⺪廨漨㸨亨度亨弫⹫弨廧仧彦潩澪廨弪⽮彬廬⻬ἲ廭㽯漫微⽲佲㻭仱⻲俳⽲⾲仱俸忶㼳伴㿷⻳徴俴⽲㾴㽵Ỳ侷侶㿶俴÷俯忲³ĳ忱³õõ´Ķ²õŶ÷øĸ÷ǹź»½ĿǿĽſļĺƿŸĸøöðð°濫翪澦徨罠廝滞滛潜罛丘羚湘溚漛绚缝缞羦澩­漥羣辡迤漦漧îݠ٠ܤڟݢݤܣޢޡृܢ٠ۢݤॄޥݢܣݤޥڣᧈ᧋ߨ᪏ݨަܦߨݥߨੌ⬋⫎઎ިިᩍ૎ߪߩ⭒ޭ᭍ଐ᭓⮓ᮔߪ⮒⯔⯓ᮔ⮑ᯔᲖ㱖ᰖ㳗㱖㳚Ⱈ㳙ᰗᱟⳞᲜ䳠᳡㶟䶟ⵝ䴟㷢㷥䷟䷡严並两乧乧乧乧乧乨乫弫产廪ḩ㹨亨产⹩潪仨产漧廧伨廥漧庨㻪们弫弭Ṭ㻪廩亪弪伭Ṭ亮Ṱ⼲ỳ侱彰㾳⹰⼵߼伴ỳ俲徴ἰὶὴ㾱⽲㻲徵⼵忴⽶⿷徶㼴忴俳侲㿲Ĵ±³ĵ±ö··ź¸·ĵ⿸žſżŽȿȻǾƿŻŸ·Ķ±澫濭翭⽬循羧羣漠湝溛幜庙帘䷙溙巚溘渚溚溛溚溜潡漦彤统羜䷘繝羦澨¬翧澩濫ڢݣࡃڠޡ۠ܢߣݣޥݤۡڡݥݥޥߤޥܤޥܤߦ਋ᩍާߨݧݨߩߧ੍᪌᪎ઊߪ৉ᫍੌ੍ᫍ߫㭐߫ૐ㰕⬐Ⱅ୒߫଑୒⯔⮕䲗⯕ᮕⱘⰘ㱗ⲘⲚ㳙㵝Ⳝⱡⱟⴟᴢ䵟ⴠ᳞㴝ⴝ䵟㳠䷢䷡ⶡ两並两丧乧乧乧乧滨仫廪弫㹧徭⸨㸧产亨弩廨滧廨潩潨漪漩㿰仫廪㹫佮伭㸧㹪⻭㼮⺭㽯侲⼱⼱伯㼲佳㽲⾳㻴侴㼴㽲㿶忳⻴侳⽲⽴忶侵侶侷ྷ⽶忶彰öµµ¶ö俳´õµ·ŹĻ÷øùøùļĿȿƾƽĺƻ¸÷õóöô俬ª翦翦漟羞滛庛減湚湚溚溚湘溙嶘绚溛湚嶙统帟廣滠滚帘帗湙帙滟鿤羢轥罤ڟ٠ڠܠ۟~ٞݡߢݡמܣݣݥءܣᦆޢߥݤܤेަܥߨڣܧ਌ੌߨߧੌߨ᪋ܤߩᩊߧߨੋݩߪᬏߩݦ߫ߪ଒߬᫑⮓⮓⫑㱗Ⱆߪ㰖ᰙᮖ䱗㲘㱘⯘㲚䳘ᱚᱝಞ㴟ⴟ㴞㴞㳝᳝ⴡ㴟㴞䵟㴝㷤並严㶤ᵤ书乧乨㹪㹬亪们乧潩幧乧乨廩弩亨弬廨ⶢ弨庨庨廩仫乩Ḫ仩⹭㹪⹭㺬佭亭⻯ṯ߸޺ἳ޸佱㼰佴⺮㼲ἴ㾷㾶ἱི㾳侴㺲徶⽰㾳侳ὶ俳㾳侲㿳·ྶø÷÷ø¹ĸĸĹº¸úĿžƾƽžĺŸŻ·µµ㾬翧缠缡滚缛幛ⷜ湚漜滙嶗溛巘溘滚绛湙湘湚巚溝廟湛巙湙䴒嶙崗嶚巖绖溙巚۝ٞ؟ڟܢݢܢ۠۟ۡڡܢڣޤݡܣݦݤܢܡܣۣܤߧަ⪌ߨݥާ᫑ߧ᪋ߧઌ⪋ߦ᪍⪌ᩌੌީݪ੎ީ᪏᫐એ਍᫐߫㭒㱘᭓୕ⱘⱙⰘⰙⰘ䵜ⲛⱙ߰߯ⳞⲠ䶢ⲜᲟ᳟ⳝⱝ䶢ⵡ㶠䴛䴛䷢㷣㶢严㸧乧乧乨们㹨㺫彬座廩弩仨亩漪㺩庩弬廨亨漨幥乧廦幨亩乫仪Ḫ⸫佭伭⻬弫亭京ṯỲ⽰Ẳ㺲㺱㾲Ự⽳⽲㾳⼷⼷⾵Ằ㾵㽴㼳㼴濳⼳ᾳྶ·侶徶徳㿵侳¸¶·ûûø÷ĺúķøùƼ㿶ŻĻ㿷Ļ¹ûľſƾĺùż¸·Ĺô´ï澧罞潞府绞绛违䷛湚溙帚䶙溛漛湙湗滙帚帙嵕渙湙湘巚嶚嶖䵖巙嶙䳗嶘嵖湘巖ٛ~ޠמٞᤀܞ{ݡޡݢ۠ޣޤܢڡ٠ߤߤݢڡ۠ݢާߥܥܤާߦަݥ਋ߨܥ਋ަ્߫ߩ᪌ީ᪍⪍૒ݧީ㬑⭓㫐᫒⫑઒ଓ⮔ᰗ૕ᮔⰘⱘⰘ⯙ᰚ䵟ⱚ㱛ⲛⳝⱜᱝⱝ㲟ⴠ㳞ⲟ䴞Ⳟ㴝䴞䵝ᴠ㴞㷣ⶣⷤ乥ⶢ丧廪享㺨廩㻨㺩庪弩乨㸧亩彬廪並弩度並廨廨仩⸨幦乪ᷧ乪享㹪Ậ伬仪㺪亪佰⹬⺯ṱ㻱⺳㽳ິ㽴㻯㻱徳侵㾶ỵ⼳⼳⺲佱侱弬彯㾷㽵念⽶㽶徳㼲·ø·¹ø¶ùĸ¸ùøŻ½¹·ƾĻƽżžǿľľĺ⿵÷³義群迟廜亜溜渙庛嶖滚湘湛嶘巘帙巕巖帘嶗渖巖嶙䳗嶗巖巖䶚䴙嶕崔嵗淖嵖巔嶔מؚ{ٞ}ڟ|۟}ݞ۟{۠۠ޢݤڠܢݤܡڠڡڟܢ৉ݤݢޤਉݧݥݥߧާߧަߨੋਉ᪊ߨߪߧިߩ᫐ߩઑ઒ީ᪑ߨ૔૒૒ᬕ߫㱖᭔ᯖᯗⱙ⯘ⱙⰗ㴠߱Ⳟᯙⱟ௞㱜᳡ᴡᲟ౞Ⲟ㳛Ⲝ䵟䶡㶡߱㶠㸣ⷦ㶠並ಟ㸦乧⸨㺫座产㸨乨乩乫们亪庨乧乨严並两座弧㺨ᷨ乧乨並乧乩⺬㹩享们伬仮伲㻬෬ݷ㺰仲⼳⼳ัẲ⺵⹳⻴ί⽶έ⽵㺲⺯㽱俯徯㽲㼳影㿵俴俴㽰㽮ö㿳ĸøĺŽ÷ķĻžƽƽǽžüĽ¾ƿ¸ƾľĸø俵濯弩羨罤缢廢丙巚帚巙巗湙巗湚巘嶔巕湗巙帚渗巔巗䳔嵕崔䴔巕帚帚嶓嶖嶕䵔嶗巘湙ڝ{ٞ|ڝ|ڟ}ڝ|ݟ|ݠ}۠ݡޣܢ۠ۡݢۡ۟ܟޤߥۣۢݣܣޥۣݤঅߦާܤᧉᩋާާߧᩊߩߩަܦިᩏ੎͚ڥ᫒ިݨުߪުଔକޫୖ⯕㯖ⰚజⰚజజ߰߯㳞ⳟᲡⴠⴢⳝ߰Ჟ߯Ო㳠㴞ᵢᱟ㶢ᵥⶤⵢ㶦䷦书㹧ᷨ㸩严ⷦ並享乧乩享乧乧乧书两乧书书㷢㹨乧廨座乧书书⹫⹩仪弭㺭㹮⹮ฬᷪ߷⹰㺰㻯⻲⺳ẳṲ߸Ẳ⻵ߺἶີ㻳⻱㼳Ẵ㻲㽱߻ή㽴俶彲ἱ⽱濱俱㿷µĸ»źþüĽþÿüĸû¹´Ķó潢䶝溛幚庙渚巙嶖嵖帖䵖渓嵒帖渗䳕溘嶖䵖䴔䲔嵖嶖巕嶗䳔淘嶖䴘㳕㳑䳓ⱒ䵕嵕۠~ٜ{ٞڜzܟڜxܠ~ٝ|ޣ۞|۟۠ܠݡ۟ۢݢेڡڠڠޢޣܣۣݥߦަߦަ੍ަ਋૎ઍਉܥݧީާ᪐ૐߩڧީ᪐ߪߪ߫᫔ݪެ߫ެ⮖୕ⱘ㳛ⲟޫ㱙ಞ௛᳟ಢ㲞ⳟⲞⲜᲡ䴟ᱛಠಠ᳡䶠ൣ㵡ఢᵥⶥߵ㸧乧乧Ḩ㸧ᷧඦ㷣两乪乩享乩京乧乧幥两严㸦乧乧㹧乧产㸧⸨两㸦ส㹫㺫亪乪㹫京อᷩ⹯亯ะḭ߷⻴Ằṱ㻳޹⺲Ỵ㺵๴⺰߸伱⺳⺱⺱⽴߸㻱⾴徱侴忰㾲俴忴´࿶µ·ĻºſĽžƿžĿĿǿżû»Ľ忴缝滚嵗䵚䵗溚渘巗渖ⴓ㴗嵕渕嵓䳓䴔嵖帖䴖嶖㳔䳗䴗嶓䴔䴔䴕䳒䳘䴘䳕䳓䳔㳖嵕䴒؜{ٛyڜ|ٜ{۝zܞz۝z۟}ڟڞ}ۡ۟ܡܠޣܡܡࣃ۠ޤޡܢܡߥܢݣݤަߦަߧަݦߧܤީ਋ާ᪐ߩިߨઐߪިߪީީ૔੒߫㭓ୖ߭߯௙௙ᰝ߮ⱝ߮ⱜ߱ⴠᰝⵢⳞᱝ㵠ⳟⴟⵟ߰߱ඣⴠᵦ⴦㴦㷦㵦㷧亪㶦ᷨ⹪幦ඦ㷥㸥䷥乪㹩ᷩ亮⸨亩滨㷥㶢ᶧ乧㷤ᷥ乧乧⸧⸧㹫㹩乪㹩⺰乪乨京亪ḩ⹭㺮ṭ㺯Ḯằ߷㺱㸯Ṳߺ޹⺵⻵Ỷ㽶㽶ີ๳Ỳ㽰⺱ἴỳ併⺲㽲㽵⽱㿷߾ùú¹½ý¿þľÿſƹ¹ò澪缣巚帚帕巚㵗渖嵒巖丙巕㴖䳓嶕䳓䳏嵓嶗䳓嵓䳔䳓䳔䴗䴕䳔䳓䳔䲑䴖䲐䳒㳑ⳕ䳖䴕䲑//
// Copyright(C) Microsoft.All rights reserved.
//
// LullabyTests.cpp
//
// Description:
//
//  Lullaby Test Implementation
//

#include <stdafx.h>
#include "powrprof.h"
#include "powrprofp.h"
#include "ntpoapi.h"

#include "initguid.h"
#include "lpe.h"
#include "QueryMachineInfo.h"
#include "AudioOffload.h"
#include "DevTrans.h"
#include "DetectBluetooth.h"

//******************************************************************************
//  CTestCase class implementation methods
//******************************************************************************
BOOL CTestCase::Initialize( void )
{
   return TRUE;
}

// ----------------------------------------------------------
void CTestCase::CleanUp ( void )
{

};

// ----------------------------------------------------------
DWORD CTestCase::RunPreTest( void )
{
    return FNS_NOTIMPLEMENTED;
};

// ----------------------------------------------------------
DWORD CTestCase::RunPostTest( void )
{
    return FNS_NOTIMPLEMENTED;
};

// ----------------------------------------------------------
DWORD CTestCase::RunDuringTest( INT /*nSyncronous*/ )
{
    return FNS_NOTIMPLEMENTED;
};


HRESULT GetSystemPowerCapabilities(SYSTEM_POWER_CAPABILITIES* SysPowerCaps)
{
    HRESULT hr = S_OK;
    NTSTATUS status;
    status = NtPowerInformation(SystemPowerCapabilities, NULL, 0, SysPowerCaps, sizeof(SYSTEM_POWER_CAPABILITIES));
    if (!NT_SUCCESS(status))
    {
        hr = HRESULT_FROM_NT(status);
        XLOG(XFAIL, eError, L"FAIL: Failed Querying for system power capabilites with (hr = %s)", GetHRString(hr));
        return hr;
    }

    return hr;
}

HRESULT IsEndpointUnderTestDigitalDisplay(BOOL& bIsDigital)
{
    HRESULT hr = S_OK;
    CLullabyDevice* pCurrentDevice = NULL;
    CComPtr<IMMDevice> spDeviceUnderTest = NULL;
    
    if (NULL == (pCurrentDevice = g_pLullabyDeviceTestModule->GetDevice()))
    {
        XLOG(XFAIL, eError, L"FAIL: IMMDevice under test was null!");
        return FALSE;
    }

    hr = pCurrentDevice->GetEndpoint(&spDeviceUnderTest);
    if (FAILED(hr))
    {
        XLOG(XFAIL, eError, L"FAIL: GetEndpoint encountered error (hr = %s).", GetHRString(hr));
        return hr;
    }

    EndpointFormFactor eFormFactor = EndpointFormFactor::UnknownFormFactor;
    hr = DevTrans::GetEndpointFormFactor(&eFormFactor, spDeviceUnderTest);
    if (FAILED(hr))
    {
        XLOG(XFAIL, eError, L"Failed getting endpoint form factor with (hr = %s)", GetHRString(hr));
        return hr;
    }

    bIsDigital = (EndpointFormFactor::DigitalAudioDisplayDevice == eFormFactor);
    return hr;
}

// ----------------------------------------------------------
BOOL CheckForDeviceAvailable()
{
    CLullabyDevice* pCurrentDevice = NULL;
    CComPtr<IMMDevice> spDeviceUnderTest = NULL;
    CComPtr<IAudioClient> spAudioClient = NULL;
    //  Get the endpoint under test
    if (NULL == (pCurrentDevice = g_pLullabyDeviceTestModule->GetDevice()))
    {
        XLOG(XFAIL, eError, L"FAIL: IMMDevice under test was null!");
        return FALSE;
    }

    HRESULT hr = pCurrentDevice->GetEndpoint(&spDeviceUnderTest);
    if (FAILED(hr))
    {
        XLOG(XFAIL, eError, L"FAIL: GetEndpoint encountered error (hr = %s).", GetHRString(hr));
        return FALSE;
    }

    hr = spDeviceUnderTest->Activate(__uuidof(IAudioClient), CLSCTX_ALL, NULL, (void**)&spAudioClient);
    if (AUDCLNT_E_DEVICE_INVALIDATED == hr)
    {
        //try again for 30s
        UINT i = 0;
        for (i = 0; i < 30 && AUDCLNT_E_DEVICE_INVALIDATED == hr; i++)
        {
            Sleep(1000);
            hr = spDeviceUnderTest->Activate(__uuidof(IAudioClient), CLSCTX_ALL, NULL, (void**)&spAudioClient);
        }

        if (FAILED(hr))
        {
            XLOG(XFAIL, eError, L"Failed Activating MMDevice(hr = %s) after %d seconds", GetHRString(hr), i);
            return FALSE;
        }
        else if (30 == i && hr != S_OK)
        {
            //we got through the loop but the device isnt ready.
            XLOG(XFAIL, eError, L"Device was not ready within 30 seconds of the machine returning from sleep");
            return FALSE;
        }
    }
    else if (FAILED(hr))
    {
        XLOG(XFAIL, eError, L"Failed Activating MMDevice(hr = %s)", GetHRString(hr));
        return FALSE;
    }

    return TRUE;
}

// ----------------------------------------------------------
DWORD Tc_Common(CTestCase* pTestCase)
{
    CComPtr<IBasicLog> pLogger;
    HRESULT hr = g_IShell->GetBasicLog(&pLogger);
    if(FAILED(hr))
    {
        XLOG(XMSG, eError, L"FAIL: Unable to create IBasicLog!");
        return FALSE;
    }

    //check if machine supports power state we are testing, skip if it does not
    SYSTEM_POWER_CAPABILITIES Capabilites = {0};
    
    hr = GetSystemPowerCapabilities(&Capabilites);
    if (FAILED(hr))
    {
        XLOG(XMSG, eError, L"FAIL: Unable query system power capabilities.");
        return FALSE;
    }

    if (PowerSystemSleeping3 == pTestCase->m_spsState)
    {
        if (!Capabilites.SystemS3)
        {
            XLOG( XMSG, eInfo2, L"Machine does not support S3. Skipping S3 testing...");
            return FNS_SKIPPED;
        }
    }
    else if (PowerSystemHibernate == pTestCase->m_spsState)
    {
        if (!Capabilites.SystemS4 || !Capabilites.HiberFilePresent)
        {
            XLOG( XMSG, eInfo2, L"Machine does not support S4. Skipping S4 testing...");
            return FNS_SKIPPED;
        }
    }
    else if (TRUE == pTestCase->m_bIsCSTest)
    {
        //skip if we are not AOAC Capable
        bool bIsAOAC = false;

        HRESULT hr = QueryMachineInfo::IsAOACCapable(pLogger, bIsAOAC);
        if (FAILED(hr))
        {
            XLOG( XMSG, eInfo2, L"Failed to determine AOAC Support(%s), skipping tests.", GetHRString(hr));
            return FNS_SKIPPED;
        }

        if (false == bIsAOAC)
        {
            XLOG( XMSG, eInfo2, L"Machine does not support AOAC, skipping tests...");
            return FNS_SKIPPED;
        }

        // we are a CS test and we support AOAC, but we need to skip if the endpoint is a digital display since they 
        // can't stream audio without a video signal being present too
        BOOL bIsEndpointDigitalDisplay = FALSE;
        hr = IsEndpointUnderTestDigitalDisplay(bIsEndpointDigitalDisplay);
        if (FAILED(hr))
        {
            XLOG( XMSG, eInfo2, L"Failed to determine query if device is a digital output with (hr = %s)", GetHRString(hr));
            return FALSE;
        }

        if (TRUE == bIsEndpointDigitalDisplay)
        {
            XLOG( XMSG, eInfo2, L"Endpoint under test is a digital output. Skipping...");
            return FNS_SKIPPED;
        }
    }

    DWORD dwRes = FNS_FAIL;
    XLOG( XMSG, eInfo1, L"%s", pTestCase->m_szTestName );
    if( FALSE == pTestCase->Initialize() )
    {
        //special case for offload return
        if (FNS_SKIPPED == pTestCase->m_dwResPre)
        {
            dwRes = FNS_SKIPPED;
        }
        XLOG( XMSG, eError, L"Failed Testcase Initialization");
        goto Exit;
    }

    dwRes = pTestCase->RunPreTest();
    if( PASSED(dwRes) == FALSE )
    {
        XLOG( XMSG, eError, L"Failed PreTest");
        goto Exit;
    }

    if (TRUE == pTestCase->m_bIsCSTest)
    {
        //run during CS to test state entry and power settings
        // pretest of the CS Classes put the machine to CS
        dwRes = pTestCase->m_dwResPost = pTestCase->RunDuringTest(pTestCase->m_nSynchronous);
        if( PASSED(dwRes) == FALSE )
        {
            goto Exit;
        }
    }
    else
    {
        //not cs, put the machine to sleep
        hr = (SuspendAndResume(pLogger, XFAIL, pTestCase->m_spsState, pTestCase->m_nSleep));
        //special case ERROR_NOT_SUPPORTED for resume timers
        if (HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr)
        {
           //already logged not supporting in the SleepResume lib
            dwRes = FNS_SKIPPED;
            goto Exit;
        }
        else if (FAILED(hr))
        {
            dwRes = FNS_FAIL;
            goto Exit;
        }
    }
    
    dwRes = pTestCase->RunPostTest();
    if( PASSED(dwRes) == FALSE )
    {
        XLOG( XMSG, eError, L"Failed Post Test");
        goto Exit;
    }

Exit:
    pTestCase->CleanUp();
    return dwRes;
}

DWORD TC_Render_Sync(SYSTEM_POWER_STATE spsState, UINT nSleep, UINT nSnooze, ApiEnum api, BOOL bOffload)
{
    CRenderTest TestCase(SYNC, spsState, nSleep, nSnooze, api, bOffload);
    return Tc_Common(&TestCase);
}
DWORD TC_Render_Async(SYSTEM_POWER_STATE spsState, UINT nSleep, UINT nSnooze, ApiEnum api, BOOL bOffload)
{
    CRenderTest TestCase(ASYNC, spsState, nSleep, nSnooze, api, bOffload);
    return Tc_Common(&TestCase);
}
DWORD TC_Capture_Sync(SYSTEM_POWER_STATE spsState, UINT nSleep, UINT nSnooze, ApiEnum api)
{
    CCaptureTest TestCase(SYNC, spsState, nSleep, nSnooze, api);
    return Tc_Common(&TestCase);
}
DWORD TC_Capture_Async(SYSTEM_POWER_STATE spsState, UINT nSleep, UINT nSnooze, ApiEnum api)
{
    CCaptureTest TestCase(ASYNC, spsState, nSleep, nSnooze, api);
    return Tc_Common(&TestCase);
}

DWORD TC_WASAPI_Render_Sync_S3()
{
    return TC_Render_Sync(PowerSystemSleeping3, 35000, 10000, api_WASAPI, FALSE);
}
DWORD TC_WASAPI_Render_Sync_SH()
{
    return TC_Render_Sync(PowerSystemHibernate, 40000, 15000, api_WASAPI, FALSE);
}
DWORD TC_WASAPI_Render_Offload_Sync_S3()
{
    return TC_Render_Sync(PowerSystemSleeping3, 35000, 10000, api_WASAPI, TRUE);
}
DWORD TC_WASAPI_Render_Offload_Sync_SH()
{
    return TC_Render_Sync(PowerSystemHibernate, 40000, 15000, api_WASAPI, TRUE);
}

DWORD TC_WASAPI_Render_Async_S3()
{
    return TC_Render_Async(PowerSystemSleeping3, 35000, 10000, api_WASAPI, FALSE);
}
DWORD TC_WASAPI_Render_Async_SH()
{
    return TC_Render_Async(PowerSystemHibernate, 40000, 15000, api_WASAPI, FALSE);
}
DWORD TC_WASAPI_Render_Offload_Async_S3()
{
    return TC_Render_Async(PowerSystemSleeping3, 35000, 10000, api_WASAPI, TRUE);
}
DWORD TC_WASAPI_Render_Offload_Async_SH()
{
    return TC_Render_Async(PowerSystemHibernate, 40000, 15000, api_WASAPI, TRUE);
}

DWORD TC_WASAPI_Capture_Sync_S3()
{
    return TC_Capture_Sync(PowerSystemSleeping3, 35000, 10000, api_WASAPI);
}
DWORD TC_WASAPI_Capture_Sync_SH()
{
    return TC_Capture_Sync(PowerSystemHibernate, 40000, 15000, api_WASAPI);
}

DWORD TC_WASAPI_Capture_Async_S3()
{
    return TC_Capture_Async(PowerSystemSleeping3, 35000, 10000, api_WASAPI);
}
DWORD TC_WASAPI_Capture_Async_SH()
{
    return TC_Capture_Async(PowerSystemHibernate, 40000, 15000, api_WASAPI);
}

DWORD TC_WASAPI_Render_Sync_CS()
{
    CCSRenderTest TestCase(SYNC, api_WASAPI, FALSE, FALSE);
    return Tc_Common(&TestCase);
}
DWORD TC_WASAPI_Render_Async_CS()
{
    CCSRenderTest TestCase(ASYNC, api_WASAPI, FALSE, FALSE);
    return Tc_Common(&TestCase);
}
DWORD TC_WASAPI_Render_Offload_Sync_CS()
{
    CCSRenderTest TestCase(SYNC, api_WASAPI, TRUE, FALSE);
    return Tc_Common(&TestCase);
}
DWORD TC_WASAPI_Render_Offload_Async_CS()
{
    CCSRenderTest TestCase(ASYNC, api_WASAPI, TRUE, FALSE);
    return Tc_Common(&TestCase);
}
/*
DWORD TC_WASAPI_Render_Async_CS_Glitch()
{
    CCSRenderTest TestCase(ASYNC, api_WASAPI, FALSE, TRUE);
    return Tc_Common(&TestCase);
}
*/
DWORD TC_WASAPI_Render_Offload_Async_CS_Glitch()
{
    CCSRenderTest TestCase(ASYNC, api_WASAPI, TRUE, TRUE);
    return Tc_Common(&TestCase);
}
DWORD TC_WASAPI_Capture_Async_CS()
{
    CCSCaptureTest TestCase(ASYNC, api_WASAPI, FALSE);
    return Tc_Common(&TestCase);
}
DWORD TC_WASAPI_Capture_Sync_CS()
{
    CCSCaptureTest TestCase(SYNC, api_WASAPI, FALSE);
    return Tc_Common(&TestCase);
}
DWORD TC_WASAPI_Capture_Async_CS_Glitch()
{
    CCSCaptureTest TestCase(ASYNC, api_WASAPI, TRUE);
    return Tc_Common(&TestCase);
}

DWORD TC_Verify_BTH()
{
    //this should only run in the system tests
#ifndef BUILD_TAEF
    if(NULL != g_pLullabyDeviceTestModule->m_pShell->m_pszHwIdTestDeviceSelect &&
        0 != lstrcmp(L"", g_pLullabyDeviceTestModule->m_pShell->m_pszHwIdTestDeviceSelect))
    {
        XLOG( XSKIP, eInfo1, L"Bluetooth presence test is run only in the system kit. Skipping...");
        return FNS_SKIPPED;
    }
#else
    using namespace WEX::Common;
    using namespace WEX::TestExecution;
    String targetDevice;
    if (SUCCEEDED(RuntimeParameters::TryGetValue(L"InstanceId", targetDevice)))
    {
        XLOG( XSKIP, eInfo1, L"Bluetooth presence test is run only in the system kit. Skipping...");
        return FNS_SKIPPED;
    }
#endif

    //
    // This test only applies to Windows 6.3 and above
    //
    OSVERSIONINFO ver = {0};
    ver.dwOSVersionInfoSize = sizeof(ver);
    if (!GetVersionEx(&ver))
    {
        XLOG(XFAIL, eFatalError, L"FAIL: GetVersionEx() failed: GetLastError() = %u", GetLastError());
        return FNS_FAIL;
    }

    XLOG(XMSG, eInfo1, L"INFO: OS version is %u.%u", ver.dwMajorVersion, ver.dwMinorVersion);

    if (ver.dwMajorVersion < 6 || (ver.dwMajorVersion == 6 && ver.dwMinorVersion < 3))
    {
        XLOG(XSKIP, eInfo1, L"INFO: This test case is only applicable to Windows versions 6.3 and above.");
        return FNS_SKIPPED;
    }

    BOOL bBthRunnging = FALSE;
    UINT cDevices = 0;

    CComPtr<IBasicLog> pLogger;
    HRESULT hr = g_IShell->GetBasicLog(&pLogger);
    if(FAILED(hr))
    {
        XLOG(XMSG, eError, L"FAIL: Unable to create IBasicLog!");
        return FNS_FAIL;
    }

    //see if there is a bth service running
    hr = DetectBluetooth::IsBthServiceRunning(pLogger, bBthRunnging);
    if(FAILED(hr))
    {
        XLOG(XMSG, eError, L"FAIL: Unable to Query Bth Services (%s)", GetHRString(hr));
        return FNS_FAIL;
    }

    if (FALSE == bBthRunnging)
    {
        XLOG(XMSG, eInfo1, L"Bluetooth is not running on the system");
        return FNS_SKIPPED;
    }

    //see how many devices are present
    hr = DetectBluetooth::BluetoothAudioDeviceCount(pLogger, &cDevices);
    if(FAILED(hr))
    {
        XLOG(XMSG, eError, L"FAIL: Unable to Query Bth device count (%s)", GetHRString(hr));
        return FNS_FAIL;
    }

    if (0 == cDevices)
    {
        XLOG(XMSG, eError, L"FAIL: BLuetooth is present on the system but there are no Bluetooth Audio Devices attached."
            L"\nPlease attach one and rerun these tests.");
        return FNS_FAIL;
    }
    else
    {
        XLOG(XMSG, eError, L"PASS: BLuetooth is present on the system and there are %d Bluetooth Audio Devices", cDevices);
    }

    return FNS_PASS;
}

DWORD TC_Verify_SleepResume()
{
    DWORD dwRes = FNS_PASS;
    CComPtr<IBasicLog> pLogger;
    HRESULT hr = g_IShell->GetBasicLog(&pLogger);
    if(FAILED(hr))
    {
        XLOG(XMSG, eError, L"FAIL: Unable to create IBasicLog!");
        return FNS_FAIL;
    }
    hr = (SuspendAndResume(pLogger, XFAIL, PowerSystemSleeping3, 35000));
    //special case ERROR_NOT_SUPPORTED for resume timers
    if (HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr)
    {
       //already logged not supporting in the SleepResume lib
        dwRes = FNS_SKIPPED;
        goto Exit;
    }
    else if (FAILED(hr))
    {
        dwRes = FNS_FAIL;
        goto Exit;
    }
    hr = (SuspendAndResume(pLogger, XFAIL, PowerSystemHibernate, 40000));
    //special case ERROR_NOT_SUPPORTED for resume timers
    if (HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) == hr)
    {
       //already logged not supporting in the SleepResume lib
        dwRes = FNS_SKIPPED;
        goto Exit;
    }
    else if (FAILED(hr))
    {
        dwRes = FNS_FAIL;
        goto Exit;
    }

Exit:
    return FNS_PASS;
}
// PresentIntervalWindowed.h: interface for the CPresentInterval class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <d3d9.h>
#include "PresentInterval.h"
#include <vector>

using namespace std;

class CPresentIntervalWindowed : public CPresentInterval
{
public:
    CPresentIntervalWindowed()
    {
		m_bFullscreen = false;
        m_BackBufferCount = 1;
        m_nMaximumFrameLatency = 3;
        m_nTe