Þ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿÞ­¾ÿ#include "PresentHelper.h"
#include "WGFTestCore.h"
#include "Strsafe.h"

#define RELEASE(a) if (!(a)){} else (a)->Release();
#define RESOURCE_PATTERN 0xacc0FAB0

#define _LOG_ERROR(errorType, errorCode, errorMessage) \
	m_pLogger->LogError(errorType, (UINT) errorCode, errorMessage, __FILEW__, __LINE__, __FUNCTION__)

#define _LOG_HRESULT_ERROR(errorCode, errorMessage) \
	_LOG_ERROR(ERROR_TYPE_HRESULT, (UINT) errorCode, errorMessage)

#define _LOG_BOOL_ERROR(errorCode, errorMessage) \
	_LOG_ERROR(ERROR_TYPE_BOOL, (UINT) errorCode, errorMessage)

//const char szVS[] = 
//	"struct VSIn\n"
//	"{\n"
//	"	float4 pos : POS;\n"
//	"};\n"
//	"struct VSOut\n"
//	"{\n"
//	"	float4 pos : SV_Position;\n"
//	"	float2 texCoord : texCoord;\n"
//	"};\n"
//	"VSOut main( VSIn input )\n"
//	"{\n"
//	"	return input; \n"
//	"}\n"
//	;

const char szVS[] = 
    "struct VSIn\n"
    "{\n"
    "	uint vertexId : VertexId;\n"
    "};\n"
    "struct VSOut\n"
    "{\n"
    "	float4 pos : SV_Position;\n"
    "	float2 texCoord : texCoord;\n"
    "};\n"
    "VSOut main( VSIn input )\n"
    "{\n"
    "	VSOut output; \n"
    "	output.pos = 0; \n"
    "	output.texCoord = 0; \n"
    "	switch (input.vertexId) \n"
    "	{\n"
    "		case 0:\n"
    "			output.pos = float4( -1.0, 1.0, 0.0, 1.0 );\n"
    "			output.texCoord = float2( 0.0, 0.0 );\n"
    "			break;\n"
    "		case 1:\n"
    "			output.pos = float4( 1.0, 1.0, 0.0, 1.0 );\n"
    "			output.texCoord = float2( 1.0, 0.0 );\n"
    "			break;\n"
    "		case 2:\n"
    "			output.pos = float4( -1.0, -1.0, 0.0, 1.0 );\n"
    "			output.texCoord = float2( 0.0, 1.0 );\n"
    "			break;\n"
    "		case 3:\n"
    "			output.pos = float4( 1.0, -1.0, 0.0, 1.0 );\n"
    "			output.texCoord = float2( 1.0, 1.0 );\n"
    "			break;\n"
    "	}\n"
    "	return output; \n"
    "}\n"
    ;

const char szPS[] = 
    "Texture2D myTex2D;\n"
    "sampler samp;\n"
    "\n"
    "struct PSIn\n"
    "{\n"
    "	float4 pos : SV_Position;\n"
    "	linear float2 texCoord : texCoord;\n"
    "};\n"
    "struct PSOut\n"
    "{\n"
    "	float4 color : SV_Target; \n"
    "};\n"
    "PSOut main( PSIn input )\n"
    "{\n"
    "	PSOut output; \n"
    "	output.color = myTex2D.Sample(samp, input.texCoord); \n"
    //"	output.color = float4(0.5,0.5,0.5,0.5); \n"
    "	return output; \n"
    "}\n"
    ;


CPresentHelper::CPresentHelper() :
    m_pDevice(nullptr),
    m_pDeviceContext(nullptr),
    m_pSwapChain(nullptr),
    m_pVB(nullptr),
    m_pVS(nullptr),
    m_pPS(nullptr),
    m_pSampler(nullptr),
    m_pRasterizer(nullptr),
    m_pRTView(nullptr),
    m_pIL(nullptr),
    m_pLogger(nullptr),
    m_pTextureData(nullptr)
{
}

CPresentHelper::~CPresentHelper()
{
    SAFE_RELEASE(m_pIL);
    SAFE_RELEASE(m_pVB);
    SAFE_RELEASE(m_pVS);
    SAFE_RELEASE(m_pPS);
    SAFE_RELEASE(m_pSampler);
    SAFE_RELEASE(m_pRasterizer);
    SAFE_RELEASE(m_pRTView);
    SAFE_RELEASE(m_pDevice);
    SAFE_RELEASE(m_pDeviceContext);
    SAFE_DELETE(m_pTextureData);
    SAFE_RELEASE(m_pLogger);
    SAFE_RELEASE(m_pSwapChain);
}

bool CPresentHelper::Setup(ID3D11RenderTargetView *pView, IDXGISwapChain *pSwapChain, ISimpleLog *pLogger)
{
    ID3D10Blob *pShader;
    ID3D10Blob *pError;
    bool bRes = false;
    HRESULT hr;

    assert(pLogger);
    assert(pSwapChain);

    m_pLogger = pLogger;
    m_pLogger->AddRef();

    m_pSwapChain = pSwapChain;
    m_pSwapChain->AddRef();

    //
    // Get the device
    //
    pView->GetDevice(&m_pDevice);

    //
    // Get the device context
    //
    m_pDevice->GetImmediateContext(&m_pDeviceContext);
    if (m_pDeviceContext == NULL)
        return false;

    //
    // Get the Backbuffer RT View
    //
    m_pRTView = pView;
    m_pRTView->AddRef();

    D3D_FEATURE_LEVEL FL = m_pDevice->GetFeatureLevel();
    bool isFL9 = (FL < D3D_FEATURE_LEVEL_10_0) ? true : false;

    //
    // Create VS
    //
    hr = D3DX10CompileFromMemory( szVS, strlen( szVS ), NULL, NULL, NULL, "main", isFL9 ? "vs_4_0_level_9_1" : "vs_4_0", 0, 0, NULL, &pShader, &pError, NULL );

    if( pError )
    {
        _LOG_BOOL_ERROR( FALSE, str2wstr(reinterpret_cast<PCSTR>(pError->GetBufferPointer())).c_str());
    }

    if( FAILED( hr ) || pError )
    {
        _LOG_HRESULT_ERROR(
            hr, 
            L"CPresentHelper::Setup() D3DX10CompileFromMemory() unexpectedly failed for VS"
            );
        goto FAIL;
    }

    if( FAILED( hr = m_pDevice->CreateVertexShader( pShader->GetBufferPointer(), pShader->GetBufferSize(), NULL, &m_pVS ) ) )
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup() - CreateVertexShader failed" );
        goto FAIL;
    }


    //
    //	Create VertexBuffer
    //
    D3D11_BUFFER_DESC BufferDesc;
    ZeroMemory(&BufferDesc, sizeof(BufferDesc));
    UINT Vertices[] = {0,1,2,3};

    BufferDesc.ByteWidth = sizeof(Vertices);
    BufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    
    D3D11_SUBRESOURCE_DATA BufferData;
    ZeroMemory(&BufferData, sizeof(BufferData));
    BufferData.pSysMem = Vertices;

    hr = m_pDevice->CreateBuffer(&BufferDesc, &BufferData, &m_pVB);
 
    if(FAILED(hr))
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup - CreateBuffer failed");
        goto FAIL;
    }

    //
    // Input Layout
    //
    D3D11_INPUT_ELEMENT_DESC Desc;
    Desc.InputSlot = 0;
    Desc.AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
    Desc.Format = DXGI_FORMAT_R8G8B8A8_UINT;
    Desc.SemanticName = "VertexID";
    Desc.SemanticIndex = 0;
    Desc.InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
    Desc.InstanceDataStepRate = 0;

    hr = m_pDevice->CreateInputLayout( &Desc, 1, pShader->GetBufferPointer(), pShader->GetBufferSize(), &m_pIL );

    if(FAILED(hr))
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup - CreateInputLayout failed");
        goto FAIL;
    }


    SAFE_RELEASE( pShader );
    SAFE_RELEASE( pError );

    //
    // Create PS
    //
    hr = D3DX10CompileFromMemory( szPS, strlen( szPS ), NULL, NULL, NULL, "main", isFL9 ? "ps_4_0_level_9_1" : "ps_4_0", 0, 0, NULL, &pShader, &pError, NULL );

    if( pError )
    {
        _LOG_BOOL_ERROR(FALSE, str2wstr(reinterpret_cast<PCSTR>(pError->GetBufferPointer())).c_str());
    }

    if( FAILED( hr ) || pError )
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup D3DX10CompileFromMemory() unexpectedly failed for PS");
        goto FAIL;
    }

    if( FAILED( hr = m_pDevice->CreatePixelShader( pShader->GetBufferPointer(), pShader->GetBufferSize(), NULL, &m_pPS ) ) )
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup - CreatePixelShader failed");
        goto FAIL;
    }


    //
    // Create Sampler
    //
    D3D11_SAMPLER_DESC sampDesc;
    ZeroMemory(&sampDesc, sizeof(sampDesc));
    sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
    sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
    sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
    sampDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
    sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
    sampDesc.MaxAnisotropy = 1;
    sampDesc.MaxLOD = isFL9 ? FLT_MAX : 0;
    sampDesc.MinLOD = 0;
    sampDesc.MipLODBias = 0;

    hr = m_pDevice->CreateSamplerState(&sampDesc, &m_pSampler);

    if( FAILED( hr ) )
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup - CreateSamplerState() failed");
        goto FAIL;
    }

    //
    //Create Rasterizer State
    //
    D3D11_RASTERIZER_DESC rastDesc;
    rastDesc.FillMode = D3D11_FILL_SOLID;
    rastDesc.CullMode = D3D11_CULL_NONE;
    rastDesc.FrontCounterClockwise = TRUE;
    rastDesc.DepthBias = 0;
    rastDesc.DepthBiasClamp = 0;
    rastDesc.SlopeScaledDepthBias = 0;
    rastDesc.DepthClipEnable = isFL9 ? TRUE : FALSE;
    rastDesc.ScissorEnable = FALSE;
    rastDesc.MultisampleEnable = FALSE;
    rastDesc.AntialiasedLineEnable = FALSE;

    hr = m_pDevice->CreateRasterizerState(&rastDesc, &m_pRasterizer);
    if (FAILED(hr))
    {
        _LOG_HRESULT_ERROR(hr, L"CPresentHelper::Setup - CreateRasterizerState() failed");
        goto FAIL;
    }

    bRes = true;

FAIL:
    SAFE_RELEASE( pShader );
    SAFE_RELEASE( pError );

    return bRes;
}

bool CPresentHelper::PresentTexture2D(ID3D11Texture2D *pTexture2D, ID3D11ShaderResourceView *pTextureView)
{
    HRESULT hr = S_OK;
    bool bRet = true;
    ID3D11Texture2D *pSRVTex2D = NULL;
    ID3D11ShaderResourceView *pSRV = NULL;
    bool bTexAddRef = false;
    bool bTexViewAddRef = false;

    if (pTextureView != NULL)
    {
        pSRV = pTextureView;
        pTextureView->AddRef();
        bTexViewAddRef = true;
    }
    else
    {
        //
        //Make sure the texture can be used as a Shader Resource View
        //Otherwise create a new texture and copy from original
        //
        D3D11_TEXTURE2D_DESC desc;
        pTexture2D->GetDesc(&desc);
        if (desc.BindFlags & D3D11_BIND_SHADER_RESOURCE)
        {
            pSRVTex2D = pTexture2D;
            pTexture2D->AddRef();
            bTexAddRef = true;
        }
        else
        {
        }

        //
        //Create a Shader Resource View
        //
        D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
        srvDesc.Format = desc.Format;
        srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        srvDesc.Texture2D.MostDetailedMip = 0;
        srvDesc.Texture2D.MipLevels = 1;
        m_pDevice->CreateShaderResourceView(pSRVTex2D, &srvDesc, &pSRV);
    }
    

    //
    //Save previous objects
    //
    ID3D11VertexShader *pOriginalVS = NULL;
    ID3D11GeometryShader *pOriginalGS = NULL;
    ID3D11PixelShader *pOriginalPS = NULL;
    ID3D11SamplerState *pOriginalSampler = NULL;
    ID3D11RasterizerState *pOriginalRasterizer = NULL;
    ID3D11ShaderResourceView *pOriginalSRV = NULL;
    ID3D11RenderTargetView *pOriginalRT = NULL;
    ID3D11DepthStencilView *pOriginalDS = NULL;
    ID3D11InputLayout *pOriginalInputLayout = NULL;
    D3D11_PRIMITIVE_TOPOLOGY originalTopology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;
    ID3D11Buffer *pOriginalVB = NULL;
    UINT OriginalVBStrides = 0;
    UINT OriginalVBOffsets = 0;

    m_pDeviceContext->VSGetShader(&pOriginalVS, NULL, NULL);
    m_pDeviceContext->GSGetShader(&pOriginalGS, NULL, NULL);
    m_pDeviceContext->PSGetShader(&pOriginalPS, NULL, NULL);
    m_pDeviceContext->PSGetSamplers(0, 1, &pOriginalSampler);
    m_pDeviceContext->PSGetShaderResources(0, 1, &pOriginalSRV);
    m_pDeviceContext->OMGetRenderTargets(1, &pOriginalRT, &pOriginalDS);
    m_pDeviceContext->RSGetState(&pOriginalRasterizer);
    m_pDeviceContext->IAGetInputLayout(&pOriginalInputLayout);
    m_pDeviceContext->IAGetPrimitiveTopology(&originalTopology);
    m_pDeviceContext->IAGetVertexBuffers(0, 1, &pOriginalVB, &OriginalVBStrides, &OriginalVBOffsets);
    //D3D11_VIEWPORT viewports[4];
    //UINT numViewports = 0;
    //m_pDeviceContext->RSGetViewports(&numViewports, viewports);


    //
    //Draw a quad with the texture
    //
    m_pDeviceContext->VSSetShader( m_pVS , NULL, 0);
    m_pDeviceContext->GSSetShader( NULL, NULL, 0 );
    m_pDeviceContext->PSSetShader( m_pPS, NULL, 0 );
    m_pDeviceContext->PSSetSamplers(0, 1, &m_pSampler);
    m_pDeviceContext->OMSetRenderTargets(1, &m_pRTView, NULL);
    m_pDeviceContext->PSSetShaderResources(0, 1, &pSRV);
    m_pDeviceContext->RSSetState(m_pRasterizer);
    m_pDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);

    UINT Stride = sizeof(UINT);
    UINT Offset = 0;
    m_pDeviceContext->IASetVertexBuffers(0, 1, &m_pVB, &Stride, &Offset);
    m_pDeviceContext->IASetInputLayout(m_pIL);


    m_pDeviceContext->Draw(4, 0);

	if (FAILED( hr = m_pSwapChain->Present(0, 0)))
	{
		bRet = false;
		_LOG_HRESULT_ERROR(hr, L"Present:  Present failed.");
	}

    //
    //Reset original objects
    //
    m_pDeviceContext->VSSetShader(pOriginalVS, NULL, 0);
    m_pDeviceContext->GSSetShader(pOriginalGS, NULL, 0);
    m_pDeviceContext->PSSetShader(pOriginalPS, NULL, 0);
    m_pDeviceContext->PSSetSamplers(0, 1, &pOriginalSampler);
    m_pDeviceContext->PSSetShaderResources(0, 1, &pOriginalSRV);
    m_pDeviceContext->OMSetRenderTargets(1, &pOriginalRT, pOriginalDS);
    m_pDeviceContext->RSSetState(pOriginalRasterizer);
    m_pDeviceContext->IASetInputLayout( pOriginalInputLayout );
    m_pDeviceContext->IASetPrimitiveTopology(originalTopology);
    m_pDeviceContext->IASetVertexBuffers(0, 1, &pOriginalVB, &OriginalVBStrides, &OriginalVBOffsets);

    //Release for all the get
    SAFE_RELEASE( pOriginalVS );
    SAFE_RELEASE( pOriginalGS );
    SAFE_RELEASE( pOriginalPS );
    SAFE_RELEASE( pOriginalSampler );
    SAFE_RELEASE( pOriginalSRV );
    SAFE_RELEASE( pOriginalRT );
    SAFE_RELEASE( pOriginalDS );
    SAFE_RELEASE( pOriginalRasterizer );
    SAFE_RELEASE( pOriginalInputLayout );
    SAFE_RELEASE( pOriginalVB);


    SAFE_RELEASE( pSRVTex2D );
    SAFE_RELEASE( pSRV );

    //if(bTexAddRef)
    //{
    //    pTexture2D->Release();
    //}
    //if(bTexViewAddRef)
    //{
    //    pTextureView->Release();
    //}

    return bRet;
}


bool CPresentHelper::PresentBuffer(ID3D11Buffer* pBuffer)
{
    bool bRet = true;
    HRESULT hr = S_OK;
    ID3D11Texture2D *pSRVTex2D = NULL;
    ID3D11ShaderResourceView *pSRV = NULL;

    hr = Create2DTexture(&pSRVTex2D);

    if(FAILED(hr))
        return false;


    D3D11_TEXTURE2D_DESC desc;
    pSRVTex2D->GetDesc(&desc);

    //
    //Create a Shader Resource View
    //
    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
    srvDesc.Format = desc.Format;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
    srvDesc.Texture2D.MostDetailedMip = 0;
    srvDesc.Texture2D.MipLevels = 1;
    m_pDevice->CreateShaderResourceView(pSRVTex2D, &srvDesc, &pSRV);
    

    //
    //Save previous objects
    //
    ID3D11VertexShader *pOriginalVS = NULL;
    ID3D11GeometryShader *pOriginalGS = NULL;
    ID3D11PixelShader *pOriginalPS = NULL;
    ID3D11SamplerState *pOriginalSampler = NULL;
    ID3D11RasterizerState *pOriginalRasterizer = NULL;
    ID3D11ShaderResourceView *pOriginalSRV = NULL;
    ID3D11RenderTargetView *pOriginalRT = NULL;
    ID3D11DepthStencilView *pOriginalDS = NULL;
    ID3D11InputLayout *pOriginalInputLayout = NULL;
    D3D11_PRIMITIVE_TOPOLOGY originalTopology = D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED;
    ID3D11Buffer *pOriginalVB = NULL;
    UINT OriginalVBStrides = 0;
    UINT OriginalVBOffsets = 0;

    m_pDeviceContext->VSGetShader(&pOriginalVS, NULL, NULL);
    m_pDeviceContext->GSGetShader(&pOriginalGS, NULL, NULL);
    m_pDeviceContext->PSGetShader(&pOriginalPS, NULL, NULL);
    m_pDeviceContext->PSGetSamplers(0, 1, &pOriginalSampler);
    m_pDeviceContext->PSGetShaderResources(0, 1, &pOriginalSRV);
    m_pDeviceContext->OMGetRenderTargets(1, &pOriginalRT, &pOriginalDS);
    m_pDeviceContext->RSGetState(&pOriginalRasterizer);
    m_pDeviceContext->IAGetInputLayout(&pOriginalInputLayout);
    m_pDeviceContext->IAGetPrimitiveTopology(&originalTopology);
    m_pDeviceContext->IAGetVertexBuffers(0, 1, &pOriginalVB, &OriginalVBStrides, &OriginalVBOffsets);


    //
    //Draw a quad with the texture
    //
    m_pDeviceContext->VSSetShader( m_pVS , NULL, 0);
    m_pDeviceContext->GSSetShader( NULL, NULL, 0 );
    m_pDeviceContext->PSSetShader( m_pPS, NULL, 0 );
    m_pDeviceContext->PSSetSamplers(0, 1, &m_pSampler);
    m_pDeviceContext->OMSetRenderTargets(1, &m_pRTView, NULL);
    m_pDeviceContext->PSSetShaderResources(0, 1, &pSRV);
    m_pDeviceContext->RSSetState(m_pRasterizer);
    m_pDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);

    UINT Stride = sizeof(UINT);
    UINT Offset = 0;
    m_pDeviceContext->IASetVertexBuffers(0, 1, &pBuffer, &Stride, &Offset);
    m_pDeviceContext->IASetInputLayout(m_pIL);


    m_pDeviceContext->Draw(4, 0);

	if (FAILED( hr = m_pSwapChain->Present(0, 0)))
	{
		bRet = false;
		_LOG_HRESULT_ERROR(hr, L"Present:  Present failed.");
	}

    //
    //Reset original objects
    //
    m_pDeviceContext->VSSetShader(pOriginalVS, NULL, 0);
    m_pDeviceContext->GSSetShader(pOriginalGS, NULL, 0);
    m_pDeviceContext->PSSetShader(pOriginalPS, NULL, 0);
    m_pDeviceContext->PSSetSamplers(0, 1, &pOriginalSampler);
    m_pDeviceContext->PSSetShaderResources(0, 1, &pOriginalSRV);
    m_pDeviceContext->OMSetRenderTargets(1, &pOriginalRT, pOriginalDS);
    m_pDeviceContext->RSSetState(pOriginalRasterizer);
    m_pDeviceContext->IASetInputLayout( pOriginalInputLayout );
    m_pDeviceContext->IASetPrimitiveTopology(originalTopology);
    m_pDeviceContext->IASetVertexBuffers(0, 1, &pOriginalVB, &OriginalVBStrides, &OriginalVBOffsets);

    //Release for all the get
    SAFE_RELEASE( pOriginalVS );
    SAFE_RELEASE( pOriginalGS );
    SAFE_RELEASE( pOriginalPS );
    SAFE_RELEASE( pOriginalSampler );
    SAFE_RELEASE( pOriginalSRV );
    SAFE_RELEASE( pOriginalRT );
    SAFE_RELEASE( pOriginalDS );
    SAFE_RELEASE( pOriginalRasterizer );
    SAFE_RELEASE( pOriginalInputLayout );
    SAFE_RELEASE( pOriginalVB);


    SAFE_RELEASE( pSRVTex2D );
    SAFE_RELEASE( pSRV );

    return bRet;
}

HRESULT CPresentHelper::Create2DTexture(ID3D11Texture2D** ppTex)
{
    D3D11_SUBRESOURCE_DATA	 subResData = {0};
    D3D11_SUBRESOURCE_DATA*  pSubResData = NULL;
    HRESULT hr = S_OK;

    UINT Width = 64;
    UINT Height = 64;
    DXGI_FORMAT DXGIFormat = DXGI_FORMAT_R8G8B8A8_UNORM;

    UINT bytesPerPixel = GetBitsPerElement(DXGIFormat) / 8;
    UINT SizeInBytes = Width * Height * bytesPerPixel;

    UINT DataSize = SizeInBytes/sizeof(ULONG);
    m_pTextureData = new ULONG[DataSize];

    //m_pTextureData is used to update texture data in resource
    for (UINT i = 0; i < DataSize; ++i)
    {
        m_pTextureData[i] = RESOURCE_PATTERN + i;
    }


    subResData.SysMemPitch = SizeInBytes / Height; // same as bytesPerPixel * m_Width

    D3D11_TEXTURE2D_DESC tex2DDesc = {0};
    tex2DDesc.ArraySize			= 1;
    tex2DDesc.Format			= DXGIFormat;
    tex2DDesc.Height			= Height;
    tex2DDesc.Width				= Width;
    tex2DDesc.MipLevels			= 1;
    tex2DDesc.SampleDesc.Count	= 1;
    tex2DDesc.SampleDesc.Quality= 0;
    tex2DDesc.BindFlags			= D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
    tex2DDesc.CPUAccessFlags	= 0;
    tex2DDesc.Usage				= D3D11_USAGE_DEFAULT;
    tex2DDesc.MiscFlags         = D3D11_RESOURCE_MISC_GENERATE_MIPS;


    hr = m_pDevice->CreateTexture2D(&tex2DDesc, pSubResData, ppTex);

    if(m_pTextureData)
    {
        delete[] m_pTextureData;
        m_pTextureData = NULL;
    }

    return hr;
}/*++

Copyright (C) Microsoft. All rights reserved.

Module Name:

    busnumspread.c

Abstract:

    This module implements routines for preconfiguring Bus numbers below a
    hotplug port.











--*/

// -------------------------------------------------------------------- Includes

#include "pcip.h"
#include "configraw.h"

// --------------------------------------------------------------------- Defines
// ----------------------------------------------------------------------- Types

//
// The BRIDGE structure is used only in this file to recurse through the
// tree of unconfigured PCI devices. To reduce the stack space used by the
// recursion, all variables which otherwise might be implemented as locals
// and which need to remain live during recursion should be kept here.
//

typedef struct _BRIDGE {
    LIST_ENTRY Link;            // Link to sibling bridges.
    LIST_ENTRY Children;        // List of child bridges.
    struct _BRIDGE *Parent;     // Parent bridge.
    PCI_SLOT_NUMBER Slot;       // Slot number of this bridge.
    UCHAR ChildCount;           // Count of child bridges.
    UCHAR BusNumCount;          // Count of all Bus numbers below this bridge.
    UCHAR HotplugCount;         // Count of all hotplug ports below this bridge.
    UCHAR Primary;              // Primary bus of this bridge.
    UCHAR Secondary;            // Secondary bus of this bridge.
    UCHAR Subordinate;          // Subordinate bus of this bridge.
    UCHAR DevicesPresent;       // Number of bridges & devices below this bridge.
    UCHAR HeaderType;           // Type of bridge
    BOOLEAN RootBus;            // Flag to represent whether the device is a PCI root bus.
    PCI_SLOT_NUMBER EnumSlot;   // Used for enumerating devices below this bridge.
    BOOLEAN FirstSlot;          // ""
    BOOLEAN AriEnabled;         // ARI is enabled on this bridge.
    BOOLEAN SlotImplemented;    // True if the bridge has slot implemented.
    BOOLEAN HotplugCapable;     // True if this bridge supports hotplug.
    ULONG ExpressCaps;          // Offset to express capabilities
    UCHAR ActualPrimary;        // Actual primary bus number of this bridge.
    UCHAR ActualSecondary;      // Actual secondary bus number of this bridge.
    PPCI_BRIDGE_REQUIREMENTS Requirements; // Holder for bridge requirements.
    BOOLEAN IsThunderBolt;      // True if the device is a thunderbolt device.
} BRIDGE, *PBRIDGE;

typedef enum _PCI_TRAVERSE_BRIDGE_DIRECTION {
    ToParent,
    ToChild
} PCI_TRAVERSE_BRIDGE_DIRECTION;

// ------------------------------------------------------------------ Prototypes

VOID
PciSpreadBridgesHotplug(
    _In_ PPCI_BUS Bus
    );

VOID
PciResetSlotEnum(
    _In_ PBRIDGE Bridge
    );

BOOLEAN
PciNextPopulatedSlot(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PBRIDGE Bridge
    );

VOID
PciAllocBridgeSubtree(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PPCI_BUS Bus,
    _In_ PBRIDGE Parent,
    _In_ UCHAR MaxSubordinate
    );

VOID
PciAssignBridgeSubtree(
    _In_ PBRIDGE Parent,
    _In_ UCHAR BusNumsPerHotplugPort,
    _In_ UCHAR BusNumsPerHotplugPortRemainder,
    _In_ UCHAR MaxSubordinate
    );

VOID
PciCommitBridgeSubtree(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PBRIDGE Parent
    );

VOID
PciFreeBridgeSubtree(
    _In_ PBRIDGE Parent
    );

VOID
PciUpdateAncestorSubordinateBuses(
    _In_ PPCI_BUS Bus,
    _In_ UCHAR Subordinate
    );

PBRIDGE
PciAllocateBridge(
    VOID
    );

VOID
PciAddBridgeWindowRequirement(
    _In_ PPCI_BRIDGE_WINDOW_REQUIREMENT Child,
    _Inout_ PPCI_BRIDGE_WINDOW_REQUIREMENT Parent
    );

VOID
PciAddBridgeWindowRequirements(
    _In_ PBRIDGE Child,
    _Inout_ PBRIDGE Parent
    );

VOID
PciAddChildRequirementsToBridgeRequirements(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ ULONG Bus,
    _In_ PCI_SLOT_NUMBER Slot,
    _In_ UCHAR HeaderType,
    _Inout_ PPCI_BRIDGE_REQUIREMENTS BridgeRequirements
    );

VOID
PciSaveBridgeRequirements(
    _In_ PBRIDGE Parent,
    _In_ PPCI_SEGMENT Segment
    );

VOID
PciOverrideRequirement(
    _In_ PPCI_BRIDGE_WINDOW_REQUIREMENT Override,
    _Inout_ PPCI_BRIDGE_WINDOW_REQUIREMENT Requirement
    );

VOID
PciAdjustBridgeRequirements(
    _Inout_ PBRIDGE Bridge
    );

ULONG PciValidateBridgeConfig(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PBRIDGE Bridge,
    _In_ ULONG Indent
    );

VOID
PciValidateBridgeConfiguration(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PBRIDGE Bridge
    );

// --------------------------------------------------------------------- Pragmas

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, PciSpreadBridgesHotplug)
    #pragma alloc_text(PAGE, PciResetSlotEnum)
    #pragma alloc_text(PAGE, PciNextPopulatedSlot)
    #pragma alloc_text(PAGE, PciAllocBridgeSubtree)
    #pragma alloc_text(PAGE, PciAssignBridgeSubtree)
    #pragma alloc_text(PAGE, PciCommitBridgeSubtree)
    #pragma alloc_text(PAGE, PciFreeBridgeSubtree)
    #pragma alloc_text(PAGE, PciUpdateAncestorSubordinateBuses)
    #pragma alloc_text(PAGE, PciAllocateBridge)
    #pragma alloc_text(PAGE, PciAddBridgeWindowRequirement)
    #pragma alloc_text(PAGE, PciAddBridgeWindowRequirements)
    #pragma alloc_text(PAGE, PciOverrideRequirement)
    #pragma alloc_text(PAGE, PciOverrideBridgeRequirements)
    #pragma alloc_text(PAGE, PciAdjustBridgeRequirements)
    #pragma alloc_text(PAGE, PciAddChildRequirementsToBridgeRequirements)
    #pragma alloc_text(PAGE, PciSaveBridgeRequirements)
    #pragma alloc_text(PAGE, PciValidateBridgeConfig)
    #pragma alloc_text(PAGE, PciValidateBridgeConfiguration)

#endif

// --------------------------------------------------------------------- Globals
// ------------------------------------------------------------------- Functions

VOID
PciSpreadBridgesHotplug(
    _In_ PPCI_BUS Bus
    )

/*++

Routine Description:

    This routine spreads out the available bus numbers between
    unconfigured bridges.  It is only called if ALL the bridges on a particular
    bus are not configured - eg we just hot docked!

Arguments:

    Bus - The bus extension for the bridge we are enumerating.

Return Value:

    None

--*/

{

    PBRIDGE Bridge;
    ULONG BusNumsAvailable;
    ULONG BusNumsLeftover;
    ULONG BusNumsNeeded;
    UCHAR BusNumsPerHotplugPort;
    UCHAR BusNumsPerHotplugPortRemainder;
    PPCI_CHILDREN_BUSNUM_HINT ChildBusNumHint;
    PPCI_DEVICE Device;
    PLIST_ENTRY Entry;
    ULONG HotplugPorts;
    UCHAR MaxSubordinate;
    ULONG NextSetBit;
    PPCI_BUS_INTERFACE_STANDARD PciIF;
    UCHAR Primary;
    UCHAR Secondary;
    UCHAR Subordinate;

    PAGED_CODE();

    PciIF = Bus->Root->PciBusInterface;

    PCI_ASSERT(LOCAL_BUS_NUMBER(Bus->SecondaryBusNumber) <= PCI_MAX_BRIDGE_NUMBER);

    Secondary = (UCHAR)LOCAL_BUS_NUMBER(Bus->SecondaryBusNumber);

    //
    // The limit is constrained by the next configured bridge underneath this
    // root bus.  The secondary bus numbers of every bridge underneath this
    // root are stored in the root bridge map.  Find the first bit
    // set in this bitmap beyond this bus's Subordinate bus number.
    // (Actually get one bit earlier than this, since the first set bit is
    // the secondary bus of another bridge.  We can
    // only consume bus numbers up to the bus number before this.)
    //

    if (LOCAL_BUS_NUMBER(Bus->SubordinateBusNumber) < PCI_MAX_BRIDGE_NUMBER) {
        NextSetBit = RtlFindSetBits(
                        &Bus->Root->BridgeMap,
                        1,
                        LOCAL_BUS_NUMBER(Bus->SubordinateBusNumber) + 1);

        //
        // If the next set bit is not found, use the bus's subordinate.
        //

        if (NextSetBit == -1) {
            MaxSubordinate = (UCHAR)Bus->SubordinateBusNumber;
        } else {
            MaxSubordinate = (UCHAR)NextSetBit;

            PCI_ASSERT(MaxSubordinate > 1);

            MaxSubordinate -= 1;
        }

    } else {
        MaxSubordinate = PCI_MAX_BRIDGE_NUMBER;
    }

    TRACE(BUS_NUMBER_TRACE_LEVEL,
          "PciSpreadBridgesHotplug: Spreading bridges between 0x%x and 0x%x\n",
          Secondary,
          MaxSubordinate
          );

    if (Secondary > MaxSubordinate) {

        //
        // This normally means the BIOS or HAL messed up and got the subordinate
        // bus number for the root bus wrong.  There's not much we can do..
        //

        TRACE(BUS_NUMBER_TRACE_LEVEL,
              "PciSpreadBridgesHotplug: Error: bus number limit %d < base %d\n",
              Secondary,
              MaxSubordinate);

        PCI_ASSERT(Secondary <= MaxSubordinate);

        return;

    } else if (Secondary == MaxSubordinate) {

        //
        // We don't have any bus numbers available - bail now
        //

        TRACE(BUS_NUMBER_TRACE_LEVEL, "PciSpreadBridgesHotplug: Error: out of bus numbers\n");
        return;
    }

    //
    // The bus should be unconfigured, hence no hint should be present yet.
    //

    if (!IsListEmpty(&Bus->ChildrenBusNumHints)) {

        PCI_ASSERT(FALSE);

        while ((!IsListEmpty(&Bus->ChildrenBusNumHints))) {
            Entry = Bus->ChildrenBusNumHints.Flink;
            RemoveEntryList(Entry);
            ChildBusNumHint = CONTAINING_RECORD(Entry,
                                                PCI_CHILDREN_BUSNUM_HINT,
                                                ListEntry);

            PciFreePool(ChildBusNumHint);
        }
    }

    //
    // Mock up a bridge to sit at the root of the hierarchy.
    //

    Bridge = PciAllocateBridge();
    if (Bridge == NULL) {
        return;
    }

    InitializeListHead(&Bridge->Children);
    Bridge->Parent = NULL;
    Bridge->ChildCount = 0;
    Bridge->BusNumCount = 1;
    Bridge->HotplugCount = 0;
    Bridge->DevicesPresent = 0;
    Bridge->Secondary = Secondary;
    Bridge->Subordinate = MaxSubordinate;
    PciAcquirePassiveLock(&Bus->ChildDeviceLock);

    //
    // The PCI root bus doesn't have a parent, nor is it
    // a PciBridge.
    //

    if (PCI_ROOT_BUS(Bus) == FALSE) {
        Bridge->Slot = Bus->PciBridge->Slot;
        Bridge->Primary = (UCHAR)Bus->ParentBus->SecondaryBusNumber;
        Bridge->ActualPrimary = Bridge->Primary;
        Bridge->ActualSecondary = Bridge->Secondary;
        Bridge->RootBus = FALSE;
        Bridge->HeaderType = PciReadHeaderTypeRaw(PciIF,
                                                  Bridge->Primary,
                                                  Bridge->Slot);

        Bridge->HeaderType &= ~PCI_MULTIFUNCTION;

        Bridge->IsThunderBolt = PciIsDeviceThunderboltRaw(PciIF,
                                                          Bridge->Primary,
                                                          Bridge->Slot);

        //
        // Update the bridges above to ensure access during enumeration.
        //

        PciUpdateAncestorSubordinateBuses(Bus, MaxSubordinate);

        //
        // Update the bridge being enumerated to open it up as wide as possible.
        //

        PciWriteBusNumsRaw(PciIF,
                           Bridge->Primary,
                           Bridge->Slot,
                           Bridge->Primary,
                           Bridge->Secondary,
                           Bridge->Subordinate);

    } else {
        Bridge->IsThunderBolt = FALSE;
        Bridge->RootBus = TRUE;
    }

    //
    // Enumerate the tree under the bridge to determine how many
    // Bus numbers and hotplug ports are needed.
    //

    PciAllocBridgeSubtree(PciIF, Bus, Bridge, MaxSubordinate);

    //
    // Retrieve the data on how many bus numbers and hotplug ports were found.
    //

    BusNumsNeeded = Bridge->BusNumCount;
    HotplugPorts = Bridge->HotplugCount;
    BusNumsAvailable = MaxSubordinate - Secondary + 1;

    //
    // Calculate how many bus numbers are still available after accounting
    // for all the actual devices which must be satisfied.
    //

    if (BusNumsAvailable > BusNumsNeeded) {
        BusNumsLeftover = BusNumsAvailable - BusNumsNeeded;

    } else {
        BusNumsLeftover = 0;
    }

    //
    // Calculate how many additional bus numbers are available to be assigned to
    // each hotplug port. If no hotplug ports were found, just set the number
    // to 0. Also calculate the remainder, and split the remainder among the
    // first N hotplug ports until it's used up.
    //

    if (HotplugPorts > 0) {
        BusNumsPerHotplugPort = BusNumsLeftover / HotplugPorts;
        BusNumsPerHotplugPortRemainder = BusNumsLeftover % HotplugPorts;
    } else {
        BusNumsPerHotplugPort = 0;
        BusNumsPerHotplugPortRemainder = 0;
    }

    //
    // Calculate the ID assignments for each bridge. This doesn't change
    // any hardware; it just sets the primary/secondary/subordinate bus numbers
    // in each bridge structure to the desired values.
    //

    PciAssignBridgeSubtree(Bridge,
                           BusNumsPerHotplugPort,
                           BusNumsPerHotplugPortRemainder,
                           MaxSubordinate);

    //
    // Write the bus numbers through the hierarchy.
    //

    PciCommitBridgeSubtree(PciIF, Bridge);

    //
    // Validate that the bus numbers were written out successfully.
    //

    PciValidateBridgeConfiguration(PciIF, Bridge);

    //
    // Save each bridge resource requirements in the segment to be used later
    // as a hint to help allocate sufficient IO/Memory to the bridge.
    //

    PciSaveBridgeRequirements(Bridge, Bus->Root->Segment);

    //
    // Free the data structure representing the tree.
    //

    PciFreeBridgeSubtree(Bridge);

    //
    // Fixup data structures maintained by the PCI driver. This only needs to
    // be done for the topmost set of bridges, which were already created
    // earlier in PciProcessNewDevice before the bus numbers were assigned in
    // this function.
    //
    // When bridges deeper in the hierarchy are enumerated later,
    // PciProcessNewDevice will discover that their bus numbers were
    // already assigned and will perform an equivalent operation.
    //

    for (Device = Bus->ChildDevices; Device != NULL; Device = Device->Sibling) {
        if ((Device->HeaderType == PCI_DEVICE_TYPE) || !Device->Present) {
            continue;
        }

        PciReadBusNumsRaw(PciIF,
                         Device->BusNumber,
                         Device->Slot,
                         &Primary,
                         &Secondary,
                         &Subordinate);

        Device->SavedRegisters.bridge.SecondaryBusNumber = Secondary;
        Device->SavedRegisters.bridge.SubordinateBusNumber = Subordinate;

        PciSetBitRangeInclusive(&Bus->BusNumberMap, Secondary, Subordinate);
        RtlSetBit(&Bus->Root->BridgeMap, Secondary);
        PCI_DEVICE_SET_FLAG(Device, BusNumbersConfigured);
        DebugClearDebugFlag(Device, PCI_BRIDGE_DISABLED);
    }

    PciReleasePassiveLock(&Bus->ChildDeviceLock);

    return;
}

VOID
PciResetSlotEnum(
    _In_ PBRIDGE Bridge
    )

/*++

Routine Description:

    This routine resets the slot enumeration for the bridge. It should be called
    once prior to enumerating slots under the bridge.

Arguments:

    Bridge - Provides a pointer to the bridge being enumerated.

Return Value:

    None

--*/

{

    PAGED_CODE();

    Bridge->FirstSlot = TRUE;
    Bridge->EnumSlot.u.bits.FunctionNumber = 0;
    Bridge->EnumSlot.u.bits.DeviceNumber = 0;
}

BOOLEAN
PciNextPopulatedSlot(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PBRIDGE Bridge
    )

/*++

Routine Description:

    This routine is used to enumerate populated slots under a bridge. On each
    return from the function, the Bridge->EnumSlot field will be updated to
    reference a slot with a device or bridge plugged in.

Arguments:

    PciIF - Provides a pointer to the root bus interface.

    Bridge - Provides a pointer to the bridge being enumerated.

Return Value:

    TRUE if a Bridge->EnumSlot points to the next populated slot.
    FALSE if no other populated slots were found.

--*/

{
    BOOLEAN Found;
    ULONG Function;

    PAGED_CODE();

    //
    // Initialize Found so that on all calls other than the first the code
    // inside the loop knows that the previous slot was found (or else the
    // caller would not have called back in to get the next slot).
    //

    Found = (Bridge->FirstSlot == FALSE);
    do {

        if (Bridge->FirstSlot == FALSE) {

            //
            // Bridge->EnumSlot contains the slot of the previously found device.
            // Increment to the next slot.
            //

            if (Bridge->AriEnabled != FALSE) {

                //
                // If ARI was when dev/fn 0 was enumerated, get the next slot
                // by examining the ARI capability of the previous slot. This
                // will provide an 8-bit function number from 0-255, where 0 is
                // the terminating condition.
                //

                Function = PciReadNextARIFunctionRaw(PciIF,
                                                     Bridge->Secondary,
                                                     Bridge->EnumSlot);

                if (Function == 0) {
                    Found = FALSE;
                    break;
                }

                //
                // Store the ARI function ID in the slot structure,
                // splitting the 8-bit function between the 5-bit device and
                // 3-bit function fields.
                //

                SET_ARI_SLOT(&Bridge->EnumSlot, Function);

            } else if ((Bridge->EnumSlot.u.bits.FunctionNumber == 0) &&
                       ((Found == FALSE) ||
                        (!PciIsDeviceMultifunction(PciIF, Bridge->Secondary, Bridge->EnumSlot)))) {

                //
                // If the last slot enumerated was function 0, there are two
                // cases where we should skip to the next device instead of
                // just incrementing the function:
                //
                // 1. Function 0 was not found. Function 0 must be implemented
                //    for each device, so if it was not found then the
                //    entire device must not be present. Note that otherwise
                //    functions need not be contiguous (e.g. a device may
                //    implement only functions {0, 2, 6}).
                //
                // 2. The device was not a multifunction device. Only
                //    multifunction devices implement functions beyond 0.
                //

                Bridge->EnumSlot.u.bits.DeviceNumber += 1;
                if (Bridge->EnumSlot.u.bits.DeviceNumber == 0) {
                    Found = FALSE;
                    break;
                }

            } else {

                //
                // Increment the function, and on overflow increment the device.
                // Note that the code relies on wraparound to 0 to detect overflow.
                //

                Bridge->EnumSlot.u.bits.FunctionNumber += 1;
                if (Bridge->EnumSlot.u.bits.FunctionNumber == 0) {
                    Bridge->EnumSlot.u.bits.DeviceNumber += 1;
                    if (Bridge->EnumSlot.u.bits.DeviceNumber == 0) {
                        Found = FALSE;
                        break;
                    }
                }
            }
        }

        //
        // Look for the device.
        //

        Found = PciIsDevicePresentRaw(PciIF, Bridge->Secondary, Bridge->EnumSlot);

        //
        // If the device was found, and it was the first slot (dev==0/fn==0),
        // check to see if ARI should be used to enumerate additional functions.
        //
        // PciTryEnableBridgeARIRaw will take the following steps:
        // 1. Determine if the device supports the ARI capability.
        // 2. Determine if the parent bridge supports ARI forwarding.
        // 3. If conditions 1 & 2 are met, enable ARI forwarding in the parent
        //    bridge and return TRUE.
        //

        if ((Found != FALSE) && (Bridge->FirstSlot != FALSE)) {
            Bridge->AriEnabled = PciTryEnableBridgeARIRaw(PciIF,
                                                          Bridge->Secondary,
                                                          Bridge->EnumSlot,
                                                          Bridge->Primary,
                                                          Bridge->Slot);
        }

        Bridge->FirstSlot = FALSE;
    } while (Found == FALSE);

    return Found;
}

VOID
PciAllocBridgeSubtree(
    _In_ PPCI_BUS_INTERFACE_STANDARD PciIF,
    _In_ PPCI_BUS Bus,
    _In_ PBRIDGE Parent,
    _In_ UCHAR MaxSubordinate
    )

/*++

Routine Description:

    This routine searches an unconfigured subtree of the PCI hierarchy below a
    specific bus to determine how many bus numbers are required for all
    populated devices, and also the number of unpopulated hotplug ports.

Arguments:

    PciIF - Provides a pointer to the root bus interface.

    Bus - Provides a pointer to the bus structure.

    Parent - Provides a pointer to the topmost bridge being enumerated.

    MaxSubordinate - Provides the bus number of the maximum subordinate bus available.

Return Value:

    None.

--*/

{

    PBRIDGE Child;
    PPCI_CHILDREN_BUSNUM_HINT ChildBusNumHint;
    PBRIDGE CurrentBridge;
    BOOLEAN DecreaseParentDevice;
    PCI_TRAVERSE_BRIDGE_DIRECTION Direction;
    BOOLEAN NotDone;
    PBRIDGE ParentBridge;
    UCHAR HeaderType;

    PAGED_CODE();

    NotDone = TRUE;
    DecreaseParentDevice = FALSE;
    Child = NULL;
    ParentBridge = NULL;
    CurrentBridge = Parent;
    Direction = ToChild;

    while (NotDone != FALSE) {
        switch (Direction) {
        case ToChild:

            //
            // Normal traversal case, will be handled later.
            //

            break;

        default:
            if (CurrentBridge == Parent) {

                //
                // The loop finishes whenever returning to the starting point
                // of the traversal (which is "parent" bridge).
                //

                return;
            } else {

                //
                // The traversal at one of the children has finished,
                // go back up one level and change the direction to ToChild to
                // continue on the next child.
                //

                if (DecreaseParentDevice != FALSE) {
                    PciFreePool(CurrentBridge);
                }

                CurrentBridge = ParentBridge;
                ParentBr